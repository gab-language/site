var relearn_searchindex = [
  {
    "breadcrumb": "Gab",
    "content": "Welcome! This guide will teach you about Gabâ€™s fundamentals. We will discuss the basic types and ideas of the language. First, lets install the language itself.\nInstalling the language Downloading binaries from releases cgab provides pre-built cross-platform binaries upon releases. They are available in both debug and release flavors. If any weird behavior or segmantation faults occur, please recreate with the debug build before filing an issue.\nInstallation All that is needed to complete the installation is this downloaded binary! From this point forward lets refer to your downloaded binary as simply gab, just to make things easier. Now, you should be able to run Gab. Try:\ngab You should see a generic help message, summarazing the commands available to you. Lets go ahead and complete your installation by downloading the core modules that Gab requires. This is easy to do with:\ngab get This command downloads the gab binary and modules to Gabâ€™s installation prefix on your machine. You should see some logs detailing this process. Lastly, complete your installation as instructed by the message in your terminal.\nNote: gab calls out to the operating system for curl and tar in order to perform this installation. They should be widely available by default on most machines, including any Windows machine with Windows 10 or later. However, you may see an error message indicating that one of the two is unavailable - in that case installation will fail.\nWindows Unforunately, windows is not supported at the moment. There is currently a bug in zig cc causing miscompilations on Windows which break the c abi. The features of c which cause this bug to appear are used heavily in cgab. Until this bug is fixed in zig, Gab will not support windows.\nCompiling From Source cgab is a c project built with Zigâ€™s c-compiler toolchain.\nUnix Systems To manage the various useful scripts in the repo, cgab takes advantage of clide. After installing clide, building cgab from source is as simple as running:\nclide build Clide will prompt you to select a build type and installation target. For details on how to use clide, check its readme.\nManual Build Alternatively, zig cc can be invoked manually. Check .clide/../build.sh for an example of how to invoke zig cc, and build the appropriate artifacts. Note: The additional flags -DGAB_PLATFORM_UNIX and -D_POSIX_C_SOURCE=200809L are required for unix builds. Clide relies on bash scripts written in the .clide/ directory, and therefore will not work on windows. On Windows, zig cc should be invoked manually. The following is an example, but will not fully build cgab.\nzig cc -O3 -std=c23 -fPIC -Wall --target=native -o gab -Iinclude -Ivendor -DNDEBUG -DGAB_PLATFORM_WIN src/**/*.c",
    "description": "Welcome! This guide will teach you about Gabâ€™s fundamentals. We will discuss the basic types and ideas of the language. First, lets install the language itself.\nInstalling the language Downloading binaries from releases cgab provides pre-built cross-platform binaries upon releases. They are available in both debug and release flavors. If any weird behavior or segmantation faults occur, please recreate with the debug build before filing an issue.\nInstallation All that is needed to complete the installation is this downloaded binary! From this point forward lets refer to your downloaded binary as simply gab, just to make things easier. Now, you should be able to run Gab. Try:",
    "tags": [],
    "title": "Introduction",
    "uri": "/intro/index.html"
  },
  {
    "breadcrumb": "GabÂ \u003eÂ IntroductionÂ \u003eÂ Basic Types",
    "content": "Lots of dynamic scripting languages make the distinction between integers and floats. Python can even upgrade numbers to the heap when they would otherwise overflow their size. Gab keeps it simple - numbers are just 64-bit floats. It is possible that in the future a distinct integer type will be added.\n1 / 3 # =\u003e 0.33333 2 * 2 # =\u003e 4",
    "description": "Lots of dynamic scripting languages make the distinction between integers and floats. Python can even upgrade numbers to the heap when they would otherwise overflow their size. Gab keeps it simple - numbers are just 64-bit floats. It is possible that in the future a distinct integer type will be added.\n1 / 3 # =\u003e 0.33333 2 * 2 # =\u003e 4",
    "tags": [],
    "title": "Arithmetic",
    "uri": "/intro/basic_types/arithmetic/index.html"
  },
  {
    "breadcrumb": "GabÂ \u003eÂ Introduction",
    "content": "In this chapter, we will learn more about Gabâ€™s basic types. At the core of any language is its values - Gab is no different. In fact - values are almost all there is in Gabâ€™s syntax. This introduction will build the foundation of how to think and program in Gab.\nNumbers Numbers are represented by IEEE 64-bit floating point values. There is no distinct integer type. Additionaly, numbers less than one require a leading zero, as shown below. This is because the plain . would conflict with another element of Gabâ€™s syntax (a message send).\n1 -42 0.2 ? # =\u003e gab\\number Note: ? is the operator for getting the type of a value.\nStrings Strings are a sequence of bytes. They are UTF8-encoded. For working with raw un-encoded bytes, Gab provides gab\\binary.\n\"gab\" \"what type am I?\" ? # =\u003e gab\\string 'Single quoted strings support escaping!\\n' Blocks Blocks are Gabâ€™s closures or functions. They use the familiar =\u003e syntax:\nsquare = (x) =\u003e x * x # =\u003e square.(2) # =\u003e 4 Blocks always have an implicit self local. On their own, it isnâ€™t very useful. It will become useful later for defining message specializations.\nget_me = () =\u003e self # =\u003e get_me.() # =\u003e Messages Messages are another obscure concept, also to be explored later. In this context, think of them as atoms or keywords - values which represent themselves. Gab takes this a step further: the type of a message is also itself.\nmessage: # =\u003e message: message: ? # =\u003e message: Messages are super useful as keys in records, to indicate success or failure in returning from blocks, as enumerations, and in many other ways. Messages can be called like blocks - however, they will look up a specialization based on the receivers type.\n+:.(2, 2) # =\u003e 4 +:.('Hello ', 'world!') # =\u003e 'Hello world!' Instead of writing out a message literal like +: and calling it, we can use a different infix notation. For operators like +:, that should look familiar!\n2 + 2 # =\u003e 4 # We've already seen another syntax for sending messages (ones that aren't operators) # Replace the colon `:` at the end with a dot `.` at the front, and you've got a message send! 'Hello world!'.println Records Records are Gabâ€™s only data structure. They serve as both dictionaries and lists.\n{ msg: 'hi' } [1, 2, 3] { name: \"Joe\" }? # =\u003e Shapes Shapes are one of the more obscure concepts in Gab. Weâ€™ll explore them further later. For now, know that all records with the same set of keys (in the same order) share the same shape.\na = { name: \"Joe\" } a ? # =\u003e b = { name: \"Rich\" } b ? # =\u003e (a ?) == (b ?) # =\u003e true: Note: A space is required between a and ?. Identifiers like a are allowed to end with either a question mark ? or an exclamation point !. This serves various conventions in Gab.\nConclusion And thats it! Gab is meant to be small and composable - the core concepts are few, but they compose in powerful ways. The chapters that follow will explore these types further!",
    "description": "In this chapter, we will learn more about Gabâ€™s basic types. At the core of any language is its values - Gab is no different. In fact - values are almost all there is in Gabâ€™s syntax. This introduction will build the foundation of how to think and program in Gab.\nNumbers Numbers are represented by IEEE 64-bit floating point values. There is no distinct integer type. Additionaly, numbers less than one require a leading zero, as shown below. This is because the plain . would conflict with another element of Gabâ€™s syntax (a message send).",
    "tags": [],
    "title": "Basic Types",
    "uri": "/intro/basic_types/index.html"
  },
  {
    "breadcrumb": "GabÂ \u003eÂ IntroductionÂ \u003eÂ Basic Types",
    "content": "This chapter will discuss the four basic string-ish types. It is meaningful to group these four types together because they share data in memory. The string \"true\" and the message true: all the share same four bytes of memory: [ 't', 'r', 'u', 'e' ]. They differentiate their type by tagging the values slightly differently - but this is an implementation detail. The important note to take from this is that converting these types into each other (eg: 'true'.messages\\into) is a constant-time operation. There is no copying, nor memory allocation.\nStrings Strings are sequences of UTF8-encoded bytes. Single-quoted strings support some escape sequences, including unicode.\n\"Hello!\" \"\\tHello\\n\" \"Hello \\u[2502]\" The gab\\string type responds to messages respecting its UTF-8 Encoding. This means that some operations actually take linear time, when you may expect them to be constant time. For example, slicing a UTF-8 string at a given index requires processing the string linearly - as UTF8 is a multi-byte character encoding and codepoints may be anywhere from one to four bytes long. On the other hand, the gab\\binary type is trivially convertible from gab\\string, and respects bytes directly, without enforcing or respecting any encoding. Becaues of this, converting from a gab\\binary to a gab\\string can fail if the binary is not valid UTF-8.\nsmiley = 'ðŸ˜€' smiley.len # =\u003e 1 smiley_bin = smiley.binaries\\into # =\u003e smiley_bin.len # =\u003e 4 There is no syntax for string interpolation, but it is easy to construct strings out of other values using make:.\nfull_name = Strings.make(\"Ada\" \" \" last_name) # The fmt package also supplies the sprintf: message 'Format a value: $'.sprintf({ name: 'bob' }) # =\u003e 'Format a value: { name: bob }' Binaries As mentioned above, the gab\\binary allows for operating on bytes directly - there is no encoding enforced. This means indexing/slicing operations are constant time. There is no syntax for constructing binary literals, but other types can be converted into binaries.\n\"This is a string\" .slice(3 8) # Requires linearly scanning from the front of the string \"This will be a binary\" .binaries\\into .slice (3 8) # slices from the 3rd to 8th byte in constant time Binaries.make('This is also makes a binary')",
    "description": "This chapter will discuss the four basic string-ish types. It is meaningful to group these four types together because they share data in memory. The string \"true\" and the message true: all the share same four bytes of memory: [ 't', 'r', 'u', 'e' ]. They differentiate their type by tagging the values slightly differently - but this is an implementation detail. The important note to take from this is that converting these types into each other (eg: 'true'.messages\\into) is a constant-time operation. There is no copying, nor memory allocation.",
    "tags": [],
    "title": "Strings",
    "uri": "/intro/basic_types/strings/index.html"
  },
  {
    "breadcrumb": "GabÂ \u003eÂ IntroductionÂ \u003eÂ Basic Types",
    "content": "Message are the bread and butter of Gab. They serve many purposes, provide control flow, as well as serving as Gabâ€™s mechanism for polymorphism.\nMessage Sends The only way to do anything is by sending a message to a value.\n\"Hello world!\" .println # =\u003e Hello world! Earlier we saw message literals, which look like this:\nprintln: Now weâ€™ve seen a message send, which is like calling a method or function:\nany_value .println Message literals can also respond to messages!\nmy_message: .println # =\u003e my_message: In fact, this is how new messages are defined in Gab!\nmy_message:.def!( myType, () =\u003e do self.name.println end) Messages themselves respond to the def!: message by adding a new implementation for the given type(s). There are several other messages for defining new implementations, which gab refers to as specializations.\n# Define multiple specializations for one message, conveniently my_message: .defcase! { nil: () =\u003e \"I was nil!\" true: () =\u003e \"I was true!\" none: \"I was none!\" # Values alone can also serve as a specialization. } # Define the same specializations for multiple types, conveniently [ myType ] .defmodule! { message_one: () =\u003e \"Sending message one\" message_two: () =\u003e \"Sending message two\" } Message Values Weâ€™ve seen message values before, they are identifiers that end in a colon:. Theyâ€™re useful for singleton values - and in fact, Gab implements booleans and nil using messages. More on this in later chapters! Gab also uses message values to implement results or optionals. Since Gab has multiple return values, sends that can error often return multiple values like this:\n# This call may fail, if Gab can't open the file (ok file) = Io.open('Maybe_Exists.txt') (ok file) # =\u003e If the file exists (ok: ) # =\u003e If the file doesn't (err: \"File not found\") # This line will crash - the record doesn't respond to age: age = { name: 'bob' } .age (ok age) = { name: 'bob' }.at(age:) # Now instead we will either see: # =\u003e (ok: 44) # =\u003e (none: nil:)",
    "description": "Message are the bread and butter of Gab. They serve many purposes, provide control flow, as well as serving as Gabâ€™s mechanism for polymorphism.\nMessage Sends The only way to do anything is by sending a message to a value.\n\"Hello world!\" .println # =\u003e Hello world! Earlier we saw message literals, which look like this:\nprintln: Now weâ€™ve seen a message send, which is like calling a method or function:",
    "tags": [],
    "title": "Messages",
    "uri": "/intro/basic_types/messages/index.html"
  },
  {
    "breadcrumb": "GabÂ \u003eÂ IntroductionÂ \u003eÂ Basic Types",
    "content": "Booleans are implemented with messages - they are not built-in keywords like in other languages!\ntrue: false: There is no if in gab. Typically, a defcase is used instead:\nmy_message: .defcase! { true: (args) =\u003e do # Do something with args in the truthy case end false: (args) =\u003e do # Do something with args in the falsey case end } some_condition .my_message args For simple use cases, there are messages and:, or:, then: and else: defined in the core library.\n# Lifted from gab's core library. truthy_values .defmodule! { and: (alt[]) =\u003e alt** or: _ =\u003e self then: f =\u003e f. self else: _ =\u003e self } falsey_values .defmodule! { and: _ =\u003e self or: (alt[]) =\u003e alt** then: _ =\u003e self else: f =\u003e f. self } The and: and or: messages do what you expect for the most part, except they donâ€™t short circuit. This means the value on the right is always evaluated.\ntrue: .and 2 # 2 false: .and 2 # .false false: .or 2 # 2 true: .or 2 # .true The then: and else: messages do short circuit, by accepting blocks instead of values.\ntrue: .then () =\u003e do # Do something in the truthy case end false: .else () =\u003e do # Do something in the falsey case end This is is the part of Gab that some may find to be most inconvenient. However, I find that it encourages writing smaller functions and more modular code, as nesting lots of scopes and conditionals is impossible.",
    "description": "Booleans are implemented with messages - they are not built-in keywords like in other languages!\ntrue: false: There is no if in gab. Typically, a defcase is used instead:\nmy_message: .defcase! { true: (args) =\u003e do # Do something with args in the truthy case end false: (args) =\u003e do # Do something with args in the falsey case end } some_condition .my_message args For simple use cases, there are messages and:, or:, then: and else: defined in the core library.",
    "tags": [],
    "title": "Booleans",
    "uri": "/intro/basic_types/booleans/index.html"
  },
  {
    "breadcrumb": "GabÂ \u003eÂ IntroductionÂ \u003eÂ Basic Types",
    "content": "Records are collections of key-value pairs. They are ordered and structurally typed.\nDictionaries Between the curly brackets {}, expressions are expected in key-value pairs. Any expression is allowed as a key or value.\na_record = { key: 'value' } a_record .key # =\u003e 'value' another_record = { key: 'value', 'another_key' 10 } another_record .at 'another_key' # =\u003e (ok: '10) Records, like all values in Gab, are immutable. This means that setting values in records returns a new record.\na_record = { key: 'value' } a_record = a_record .key 'another value' # =\u003e When an argument is provided, this message serves as a 'set' instead of a 'get'. a_record # =\u003e { key: 'another value' } a_record = a_record .put (key: 'something else') a_record # =\u003e { key: 'something else' } Lists Lists are constructed with the square brackets [], and any number of expressions are allowed inside. Lists are a special kind of record - one in which all they keys are ascending integers, starting from 0.\na_list = [1 2 3] a_list # =\u003e [1, 2, 3] a_list = { 0 1, 1 2, 2 3 } a_list # =\u003e [1, 2, 3] Records Both Dictionaries and Lists use the same underlying datastructure, gab\\record. In order to make these immutable data structures fast, records are implemented with a bit partitioned vector trie. Gabâ€™s implementation is very much inspired by clojureâ€™s immutable vectors. Records are able to share memory under the hood, to avoid copying large of data for a single key-value mutation. This is called structural sharing, and is a common optimization in immutable data structures.\nAs seen above, gab\\record implements some useful messages put: and at:.\nsome_record .at key: # =\u003e (ok:, 'value') Shapes All records have an underlying shape. They determine the available keys, and their order - think of them as an implicit class. Records with the same keys in the same order share the same shape.\nsome_record = { x: 1 y: 2 } shape_x_y = some_record ? # =\u003e ({ x: 2 y: 3 } ?) == shape_x_y # =\u003e true: Shapes are useful for defining methods. When resolving which specialization to use for a given value, Gab checks in the following order:\nIf the value has a super type, and it has an available specialization, use it. If available, use the typeâ€™s specialization. If available, use the property. If available, use the general specialization. No specialization found. For example: { x: 1 } has a super type of \u003cgab\\shape x:\u003e, and a type of gab\\record.\n# Define the message y: in the general case. y: .def! 'general case' # Define the message z: in the case of z: .def! ( Shapes.make x:, 'shape case') { x: 1 } .x # =\u003e 2 { x: 1 } .y # =\u003e 'general case' { x: 1 } .z # =\u003e 'shape case'",
    "description": "Records are collections of key-value pairs. They are ordered and structurally typed.\nDictionaries Between the curly brackets {}, expressions are expected in key-value pairs. Any expression is allowed as a key or value.\na_record = { key: 'value' } a_record .key # =\u003e 'value' another_record = { key: 'value', 'another_key' 10 } another_record .at 'another_key' # =\u003e (ok: '10) Records, like all values in Gab, are immutable. This means that setting values in records returns a new record.",
    "tags": [],
    "title": "Records",
    "uri": "/intro/basic_types/records/index.html"
  },
  {
    "breadcrumb": "",
    "content": "A dynamic and open source programming language focused on simplicity. welcome_message = ['Hello', ' ', 'world!'] welcome_message.join.println # =\u003e Hello world! The syntax of the language is minimal by design - it can be learned within an hour. This is entirely driven by the fact that there is only one mechanism for control flow: sending messages. Say goodbye to if, for, and while!\nConcerned with Concurrency. print_chan = Channels.make Ranges.make(0 10000).each i =\u003e do Fibers.make () =\u003e do print_chan \u003c! 'Hello, from fiber$!'.sprintf(i) end end print_chan.each println: Gabâ€™s custom runtime environment supports hundreds of thousands of concurrent fibers. Fibers communicate with each other throuch channels - another core datatype to the language. Unlike Go and other implementations of CSP, Gab channels are always unbuffered. They serve as a synchronization point for fibers, as well as a way to pass around data. Which, by the way, is done with zero copying in Gab.\nImmutable by default. (and always) bob = { name: 'bob', age: 44 } # =\u003e { name: 'bob' age: 44 } alice = bob.put(name: 'alice') # =\u003e { name: 'alice' age: 44 } bob # =\u003e { name: 'bob' age: 44 } All of Gabâ€™s data structures are immutable (Yes, even gab\\channel). For a language focused on concurrency, immutability is the only sensible option. Gabâ€™s immutable record is implemented with a custom Hash-Array-BitMapped-Vector-Trie, heavily inspired by clojureâ€™s persistent vector. In truth, gab\\record is the only data structure in the language. Traditional square-bracket [] lists use the same data structure (and gab\\shape principle - more on that later).\nDesigned for performance. Many of todays dynamic or interpreted languages made decisions early in their design which have left them difficult to make fast. This is a tradeoff - these choice make the languages more convenient, or maybe served a purpose that has become obsolete. Gab has constrained itself in order to make competetive performance easier to achieve. Said tradeoffs:\nNo global variables. No implicit conversions. gab\\channel is always unbuffered. No control flow - other than sending messages. Only one data structure, gab\\record. Gabâ€™s small surface area also plays a part here. Since Gab only has one mechanism for control flow (messages) and one data-structure (gab\\record), that leaves only two hot code-paths in cgabâ€™s implementation. All optimization efforts can focus on improving either message dispatch or record operations.\nWhatâ€™s in a name? According to Merriam Webster:\ngab intransitive verb to talk in a rapid or thoughtless manner, ie: chatter",
    "description": "A dynamic and open source programming language focused on simplicity. welcome_message = ['Hello', ' ', 'world!'] welcome_message.join.println # =\u003e Hello world! The syntax of the language is minimal by design - it can be learned within an hour. This is entirely driven by the fact that there is only one mechanism for control flow: sending messages. Say goodbye to if, for, and while!\nConcerned with Concurrency. print_chan = Channels.make Ranges.make(0 10000).each i =\u003e do Fibers.make () =\u003e do print_chan \u003c! 'Hello, from fiber$!'.sprintf(i) end end print_chan.each println: Gabâ€™s custom runtime environment supports hundreds of thousands of concurrent fibers. Fibers communicate with each other throuch channels - another core datatype to the language. Unlike Go and other implementations of CSP, Gab channels are always unbuffered. They serve as a synchronization point for fibers, as well as a way to pass around data. Which, by the way, is done with zero copying in Gab.",
    "tags": [],
    "title": "Gab",
    "uri": "/index.html"
  },
  {
    "breadcrumb": "Gab",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "Gab",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
