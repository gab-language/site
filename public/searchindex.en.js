var relearn_searchindex = [
  {
    "breadcrumb": "",
    "content": "Welcome! This guide will teach you about Gab’s fundamentals. We will discuss the basic types and ideas of the language. First, lets install the language itself.\nInstalling the language Downloading binaries from releases CGab provides pre-built cross-platform binaries upon releases. They are available in both debug and release flavors (If any weird behavior or segmantation faults occur, please recreate with the debug build before filing an issue).\nInstallation ALl that is needed to complete the installation is this downloaded binary! The binary freshly downloaded from Github won’t be marked as executable. On Unix systems, we’ll need to fix that:\nchmod +x \u003cyour_downloaded_binary\u003e From this point forward lets refer to your downloaded binary as simply gab, just to make things easier. Now, you should be able to run Gab. Try:\n./gab You should see a generic help message, summarazing the commands available to you. Lets go ahead and complete your installation by downloading the core modules that Gab requires. This is easy to do with:\n./gab get This command downloads the gab binary and modules to Gab’s installation prefix on your machine. You should see some logs detailing this process. Lastly, complete your installation as instructed by the message in your terminal.\nNote: gab calls out to the operating system for curl and tar in order to perform this installation. They should be widely available by default on most machines, including any Windows machine with Windows 10 or later. However, you may see an error message indicating that one of the two is unavailable - in that case installation will fail.\nCompiling From Source CGab is a c project built with Zig’s c-compiler toolchain.\nUnix Systems To manage the various useful scripts in the repo, cgab takes advantage of clide. After installing clide, building cgab from source is as simple as running:\nclide build Alternatively, zig cc can be invoked manually as below for Windows. Note: The additional flags -DGAB_PLATFORM_UNIX and -D_POSIX_C_SOURCE=200809L are required for unix builds.\nWindows Systems Clide relies on bash scripts written in the .clide/ directory, and therefore will not work on windows. On Windows, zig cc should be invoked manually.\nzig cc -O3 -std=c23 -fPIC -Wall --target=native -o gab -Iinclude -Ivendor -DNDEBUG -DGAB_PLATFORM_WIN src/**/*.c",
    "description": "Welcome! This guide will teach you about Gab’s fundamentals. We will discuss the basic types and ideas of the language. First, lets install the language itself.\nInstalling the language Downloading binaries from releases CGab provides pre-built cross-platform binaries upon releases. They are available in both debug and release flavors (If any weird behavior or segmantation faults occur, please recreate with the debug build before filing an issue).\nInstallation ALl that is needed to complete the installation is this downloaded binary! The binary freshly downloaded from Github won’t be marked as executable. On Unix systems, we’ll need to fix that:",
    "tags": [],
    "title": "Introduction",
    "uri": "/intro/index.html"
  },
  {
    "breadcrumb": "Introduction",
    "content": "In this chapter, we will learn more about Gab’s basic types. It will build the foundation of how to think and program in Gab.\nNumbers Numbers are represented by IEEE 64-bit floating point values. There is no distinct integer type.\n1 0.2 ? # =\u003e gab\\number Note: ? is the operator for getting the type of a value.\nStrings Strings are just a sequence of bytes.\n\"gab\" \"what type am I?\" ? # =\u003e gab\\string Records Records are both dictionaries and lists.\n{ msg: 'hi' } [1, 2, 3] { name: \"Joe\" } ? # =\u003e Shapes Shapes are one of the more obscure concepts in Gab. We’ll explore them further later. For now, know that all records with the same set of keys (in the same order) share the same shape.\na = { name: \"Joe\" } b = { name: \"Rich\" } (a ?) == (b ?) # =\u003e true: Messages Messages are another obscure concept, also to be explored later. To begin, just think of them as methods. They also serve as constants whose value and type is just their name.\nmessage: message: ? # message: Conclusion And thats it! Gab is meant to be small and composable - the core concepts are few, but they combine in powerful ways. The chapters that follow will go explore these types further.",
    "description": "In this chapter, we will learn more about Gab’s basic types. It will build the foundation of how to think and program in Gab.\nNumbers Numbers are represented by IEEE 64-bit floating point values. There is no distinct integer type.\n1 0.2 ? # =\u003e gab\\number Note: ? is the operator for getting the type of a value.\nStrings Strings are just a sequence of bytes.\n\"gab\" \"what type am I?\" ? # =\u003e gab\\string Records Records are both dictionaries and lists.",
    "tags": [],
    "title": "Basic Types",
    "uri": "/intro/basic_types/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Basic Types",
    "content": "Message Sends The only way to do anything is by sending a message to a value.\n\"Hello world!\" .println # =\u003e Hello world! Earlier we saw message literals, which look like this:\nprintln: Now we’ve seen a message send, which is like calling a method or function:\nany_value .println Message literals can also respond to messages!\nmy_message: .println # =\u003e my_message: In fact, this is how new messages are defined in Gab!\nmy_message:.def!( myType, () =\u003e do self.name.println end) Messages themselves respond to the def!: message by adding a new implementation for the given type(s). There are several other messages for defining new implementations, which gab refers to as specializations.\n# Define multiple specializations for one message, conveniently my_message: .defcase! { nil: () =\u003e \"I was nil!\" true: () =\u003e \"I was true!\" none: \"I was none!\" # Values alone can also serve as a specialization. } # Define the same specializations for multiple types, conveniently [ myType ] .defmodule! { message_one: () =\u003e \"Sending message one\" message_two: () =\u003e \"Sending message two\" } Message Values We’ve seen message values before, they are identifiers that end in a colon:. They’re useful for singleton values - and in fact, Gab implements booleans and nil using messages. More on in this in later chapters! Gab also uses message values to implement results or optionals. Since Gab has multiple return values, sends that can error often return multiple values like this:\n(ok file) = Io.open('Maybe_Exists.txt') (ok file) # =\u003e If the file exists (ok: ) # =\u003e If the file doesn't (err: \"File not found\")",
    "description": "Message Sends The only way to do anything is by sending a message to a value.\n\"Hello world!\" .println # =\u003e Hello world! Earlier we saw message literals, which look like this:\nprintln: Now we’ve seen a message send, which is like calling a method or function:\nany_value .println Message literals can also respond to messages!\nmy_message: .println # =\u003e my_message: In fact, this is how new messages are defined in Gab!",
    "tags": [],
    "title": "Messages",
    "uri": "/intro/basic_types/messages/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Basic Types",
    "content": "Records are collections of key-value pairs. They are ordered and structurally typed.\nDictionaries Between the curly brackets {}, expressions are expected in key-value pairs. Any expression is allowed as a key or value.\na_record = { key: 'value' } a_record .key # =\u003e 'value' another_record = { key: 'value', 'another_key' 10 } another_record .at 'another_key' # =\u003e (ok: '10) Records, like all values in Gab, are immutable. This means that setting values in records returns a new record.\na_record = { key: 'value' } a_record = a_record .key 'another value' # =\u003e When an argument is provided, this message serves as a 'set' instead of a 'get'. a_record # =\u003e { key: 'another value' } a_record = a_record .put (key: 'something else') a_record # =\u003e { key: 'something else' } Lists Lists are constructed with the square brackets [], and any number of expressions are allowed inside. Lists are a special kind of record - one in which all they keys are ascending integers, starting from 0.\na_list = [1 2 3] a_list # =\u003e [1, 2, 3] a_list = { 0 1, 1 2, 2 3 } a_list # =\u003e [1, 2, 3] Records Both Dictionaries and Lists use the same underlying datastructure, gab\\record. In order to make these immutable data structures fast, records are implemented with a bit partitioned vector trie. Gab’s implementation is very much inspired by clojure’s immutable vectors. Records are able to share memory under the hood, to avoid copying large of data for a single key-value mutation. This is called structural sharing, and is a common optimization in immutable data structures.\nAs seen above, gab\\record implements some useful messages put: and at:.\nsome_record .at key: # =\u003e (ok:, 'value') Shapes All records have an underlying shape. They determine the available keys, and their order - think of them as an implicit class. Records with the same keys in the same order share the same shape.\nsome_record = { x: 1 y: 2 } shape_x_y = some_record ? # =\u003e ({ x: 2 y: 3 } ?) == shape_x_y # =\u003e true: Shapes are useful for defining methods. When resolving which specialization to use for a given value, Gab checks in the following order:\nIf the value has a super type, and it has an available specialization, use it. If available, use the type’s specialization. If available, use the property. If available, use the general specialization. No specialization found. For example: { x: 1 } has a super type of \u003cgab\\shape x:\u003e, and a type of gab\\record.\n# Define the message y: in the general case. y: .def! 'general case' # Define the message z: in the case of z: .def! ( Shapes.make x:, 'shape case') { x: 1 } .x # =\u003e 2 { x: 1 } .y # =\u003e 'general case' { x: 1 } .z # =\u003e 'shape case'",
    "description": "Records are collections of key-value pairs. They are ordered and structurally typed.\nDictionaries Between the curly brackets {}, expressions are expected in key-value pairs. Any expression is allowed as a key or value.\na_record = { key: 'value' } a_record .key # =\u003e 'value' another_record = { key: 'value', 'another_key' 10 } another_record .at 'another_key' # =\u003e (ok: '10) Records, like all values in Gab, are immutable. This means that setting values in records returns a new record.",
    "tags": [],
    "title": "Records",
    "uri": "/intro/basic_types/records/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Basic Types",
    "content": "This chapter will discuss the four basic string-ish types. It is meaningful to group these four types together because they share data in memory. The string \"true\" and the message \\true all the share same four bytes of memory: [ 't', 'r', 'u', 'e' ]. They differentiate their type by tagging the values slightly differently - but this is an implementation detail. The important note to take from this is that converting these types into each other (eg: 'true'.messages\\into) is a constant-time operation. There is no copying, nor memory allocation.\nStrings Strings are just sequences of bytes. They support some escape sequences, including unicode.\n\"Hello!\" \"\\tHello\\n\" \"Hello \\u[2502]\" The gab\\string type responds to messages respecting its UTF-8 Encoding. This means that some operations actually take linear time, when you may expect them to be constant time. For example, slicing a UTF-8 string at a given index requires processing the string linearly - as UTF8 is a multi-byte character encoding and codepoints are anywhere from one to four bytes long. The gab\\binary type is trivially convertible from gab\\string, and respects the bytes directly. There is no syntax for string interpolation, but it is easy to construct strings out of other values using make:.\nfull_name = Strings.make(\"Ada\" \" \" last_name) Binaries As mentioned above, the gab\\binary allows for operating on bytes directly - there is no encoding enforced. This means indexing/slicing operations are constant time. There is no syntax for constructing binary literals, but other types can be converted into binaries.\n\"This is a string\" .slice(3 8) # Requires linearly scanning from the front of the string \"This will be a binary\" .binary\\into .slice (3 8) # slices from the 3rd to 8th byte in constant time Binaries.make('This is also makes a binary') Messages A message is a constant whose value and type is itself. They are similar to atoms or symbols in other languages. They are useful for enumerating possible values, or tagging records.\napple: == apple: # .true apple: == orange: # .false apple: ? # apple: orange: ? # orange:",
    "description": "This chapter will discuss the four basic string-ish types. It is meaningful to group these four types together because they share data in memory. The string \"true\" and the message \\true all the share same four bytes of memory: [ 't', 'r', 'u', 'e' ]. They differentiate their type by tagging the values slightly differently - but this is an implementation detail. The important note to take from this is that converting these types into each other (eg: 'true'.messages\\into) is a constant-time operation. There is no copying, nor memory allocation.",
    "tags": [],
    "title": "Strings",
    "uri": "/intro/basic_types/strings/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Basic Types",
    "content": "Booleans are implemented with messages - they are not built-in keywords like in other languages!\ntrue: false: There is no if in gab. Typically, a defcase is used instead:\nmy_message: .defcase! { true: (args) =\u003e do # Do something with args in the truthy case end false: (args) =\u003e do # Do something with args in the falsey case end } some_condition .my_message args For simple use cases, there are messages and:, or:, then: and else: defined in the core library.\n# Lifted from gab's core library. truthy_values .defmodule! { and: (alt[]) =\u003e alt** or: _ =\u003e self then: f =\u003e f. self else: _ =\u003e self } falsey_values .defmodule! { and: _ =\u003e self or: (alt[]) =\u003e alt** then: _ =\u003e self else: f =\u003e f. self } The and: and or: messages do what you expect for the most part, except they don’t short circuit. This means the value on the right is always evaluated.\ntrue: .and 2 # 2 false: .and 2 # .false false: .or 2 # 2 true: .or 2 # .true The then: and else: messages do short circuit, by accepting blocks instead of values.\ntrue: .then () =\u003e do # Do something in the truthy case end false: .else () =\u003e do # Do something in the falsey case end",
    "description": "Booleans are implemented with messages - they are not built-in keywords like in other languages!\ntrue: false: There is no if in gab. Typically, a defcase is used instead:\nmy_message: .defcase! { true: (args) =\u003e do # Do something with args in the truthy case end false: (args) =\u003e do # Do something with args in the falsey case end } some_condition .my_message args For simple use cases, there are messages and:, or:, then: and else: defined in the core library.",
    "tags": [],
    "title": "Booleans",
    "uri": "/intro/basic_types/booleans/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Basic Types",
    "content": "1 / 3",
    "description": "1 / 3",
    "tags": [],
    "title": "Arithmetic",
    "uri": "/intro/basic_types/arithmetic/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
