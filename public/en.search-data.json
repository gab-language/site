{"/docs/":{"data":{"":"","#":"Documentation "},"title":"Docs"},"/docs/intro/":{"data":{"":"Welcome!\nThis guide will teach you about Gab’s fundamentals.\nWe will discuss the basic types and ideas of the language.\nFirst, lets install the language itself.","compiling-from-source#Compiling From Source":"cgab is a C project built with Zig’s c-compiler toolchain. zig cc is chosen specifically for its cross-compiling superpowers. This enables linux developers to cross-compile for Windows and run via wine, among other amazing things. As a result, a limitation placed on cgab is that there shall be no runtime dependencies other than libc. This constraint is what makes the cross compilation possible. This goes for any c modules as well - there may be NO runtime dependencies. Any 3rd party code necessary for c modules shall be kept in git-submodules, and if it must be linked, then linked statically.\nUnix Systems To manage the various useful scripts in the repo, cgab takes advantage of clide. After installing clide, building cgab from source is as simple as running:\nclide build Clide will prompt you to select a build type and installation target. For details on how to use clide, check its readme.\nManual Build Alternatively, zig cc can be invoked manually. Check .clide/../build.sh for an example of how to invoke zig cc, and build the appropriate artifacts.\nNote\nThe additional flags -DGAB_PLATFORM_UNIX and -D_POSIX_C_SOURCE=200809L are required for unix builds. Clide relies on bash scripts written in the .clide/ directory, and therefore will not work on windows. On Windows, zig cc should be invoked manually. The following is an example, but will not fully build cgab.\nzig cc -O3 -std=c23 -fPIC -Wall --target=native -o gab -Iinclude -Ivendor -DNDEBUG -DGAB_PLATFORM_WIN src/**/*.c ","installing-the-language#Installing the language":"1. Downloading binaries from releases cgab provides pre-built cross-platform binaries upon releases. They are available in both debug and release flavors. Select a pre-built binary that matches your system. If you don’t see one, feel free to create a Github Issue or build cgab yourself.\nNote\nThe executable you just downloaded (gab) won’t be in your path. You’ll need to invoke it directly. Later, Gab will recommend how to update your PATH as part of installation. Ultimately, this is up to you!\n2. Install via binary All that is needed to complete the installation is this downloaded binary! From this point forward lets refer to your downloaded binary as simply gab, just to make things easier. Now, you should be able to run Gab.\n# Try this: gab # Or this: gab help You should see a generic help message, summarazing the commands available to you. However, at this point trying to run any real code will fail - Gab’s core modules still need to be installed. Lets go ahead and complete your installation by downloading the core modules that Gab requires.\n# Gab makes this easy: gab get This command downloads the gab binary and modules to Gab’s installation prefix on your machine. You should see some logs detailing this process. Lastly, complete your installation as instructed by the message in your terminal.\nNote\ngab calls out to the operating system for curl and tar in order to perform this installation. They should be widely available by default on most machines, including any Windows machine with Windows 10 or later. However, you may see an error message indicating that one of the two is unavailable - in that case installation will fail.","windows#Windows":"Unforunately, windows is not supported at the moment. There is currently a bug in zig cc causing miscompilations on Windows which break the c abi. The features of c which cause this bug to appear are used heavily in cgab. Until this bug is fixed in zig, Gab will not support windows."},"title":"Introduction"},"/docs/intro/basic_types/":{"data":{"":"","#":"In this chapter, we will learn more about Gab’s basic types. At the core of any language is its values - Gab is no different. In fact - values are almost all there is in Gab’s syntax. This introduction will build the foundation of how to think and program in Gab.\nNumbers Numbers are represented by IEEE 64-bit floating point values. There is no distinct integer type.\n1 -42 0.2 ? # =\u003e gab\\number Note\nNumbers less than one require a leading zero, as shown below.\nThis is because the plain . would conflict with another element of Gab’s syntax (a message send).\nStrings Strings are a sequence of bytes. They are UTF8-encoded. For working with raw un-encoded bytes, Gab provides gab\\binary.\n\"gab\" \"what type am I?\" ? # =\u003e gab\\string 'Single quoted strings support escaping!\\n' As seen above, the operator for inspecting the type of a value is the question mark.\nBlocks Blocks are Gab’s closures or functions. They use the familiar =\u003e syntax:\nsquare = (x) =\u003e x * x # =\u003e square.(2) # =\u003e 4 Blocks always have an implicit self local. On their own, it isn’t very useful. It will become useful later for defining message specializations.\nget_me = () =\u003e self # =\u003e get_me.() # =\u003e Messages Messages are another obscure concept, also to be explored later. In this context, think of them as atoms or keywords - values which represent themselves. Gab takes this a step further: the type of a message is also itself.\nmessage: # =\u003e message: message: ? # =\u003e message: Messages are useful as keys in records, to indicate success or failure in returning from blocks, as enumerations, and in many other ways. Messages can also be called like blocks - however, they will look up a specialization based on the receiver’s type.\n+:.(2, 2) # =\u003e 4 +:.('Hello ', 'world!') # =\u003e 'Hello world!' Instead of writing out a message literal like +: and calling it, we can use a different infix notation. For operators like +:, that should look familiar!\n2 + 2 # =\u003e 4 # We've already seen another syntax for sending messages # (ones that aren't operators) # Replace the colon `:` at the end with a dot `.` at the front, # and you've got a message send! 'Hello world!'.println Records Records are Gab’s only data structure. They serve as both dictionaries and lists.\n{ msg: 'hi' } [1, 2, 3] { name: \"Joe\" }? # =\u003e Shapes Shapes are one of the more obscure concepts in Gab. We’ll explore them further later. For now, know that all records with the same set of keys (in the same order) share the same shape.\na = { name: \"Joe\" } a ? # =\u003e b = { name: \"Rich\" } b ? # =\u003e (a ?) == (b ?) # =\u003e true: Note\nA space is required between a and ?. Identifiers like a are allowed to end with either a question mark ? or an exclamation point !. This serves various conventions in Gab.\nFibers gab\\fiber is a green thread - similar to processes on the BEAM, and goroutines in golang.\nFibers.make () =\u003e do 'I could run on another os thread!' end Fibers are created as above, and automaticaly queued up for execution. The block passed to make: will run, potentially on another operating-system thread. As all Gab values are immutable, the block passed here may capture any variables it likes. However, communicating to this fiber once its created is only possible through a gab\\channel.\nChannels Channels are a synchronized portal for handing off values between two gab\\fibers.\nch = Channels.make # \u003c!: is a blocking operation to put a value onto a channel Fibers.make () =\u003e ch \u003c! 'Hello world!' # \u003e!: is the opposite - a blocking operation for taking values out. ch.\u003e!.println A fiber waiting on a channel operation may not continue executing until either the operation completes or the channel closes. To prevent fibers from hogging the CPU while they wait, they may yield the CPU to other fibers and will retry their operation at a later time.\nNote\nEven the put message \u003c!: must block until a receiver arrives to become responsible for the passing value. This is required by Gab’s runtime, as the gab\\channel value is immutable and cannot hold references to other values.","conclusion#Conclusion":"And thats it! Gab is meant to be small and composable - the core concepts are few, but they compose in powerful ways. The chapters that follow will explore these types further!"},"title":"Basic Types"},"/docs/intro/basic_types/arithmetic/":{"data":{"":"Lots of dynamic scripting languages make the distinction between integers and floats. Python can even upgrade numbers to the heap when they would otherwise overflow their size. Gab keeps it simple - numbers are just 64-bit floats. It is possible that in the future a distinct integer type will be added.\n1 / 3 # =\u003e 0.33333 2 * 2 # =\u003e 4 "},"title":"Arithmetic"},"/docs/intro/basic_types/booleans/":{"data":{"":"Booleans are implemented with messages - they are not built-in keywords like in other languages!\ntrue: false: There is no if in gab. Typically, a defcase is used instead:\nmy_message: .defcase! { true: (args) =\u003e do # Do something with args in the truthy case end false: (args) =\u003e do # Do something with args in the falsey case end } some_condition .my_message args For simple use cases, there are messages and:, or:, then: and else: defined in the core library.\n# Lifted from gab's core library. truthy_values .defmodule! { and: (alt[]) =\u003e alt** or: _ =\u003e self then: f =\u003e f. self else: _ =\u003e self } falsey_values .defmodule! { and: _ =\u003e self or: (alt[]) =\u003e alt** then: _ =\u003e self else: f =\u003e f. self } The and: and or: messages do what you expect for the most part, except they don’t short circuit. This means the value on the right is always evaluated.\ntrue: .and 2 # 2 false: .and 2 # .false false: .or 2 # 2 true: .or 2 # .true The then: and else: messages do short circuit, by accepting blocks instead of values.\ntrue: .then () =\u003e do # Do something in the truthy case end false: .else () =\u003e do # Do something in the falsey case end This is is the part of Gab that some may find to be most inconvenient. However, I find that it encourages writing smaller functions and more modular code, as nesting lots of scopes and conditionals is impossible."},"title":"Booleans"},"/docs/intro/basic_types/messages/":{"data":{"":"","#":"Message are the bread and butter of Gab. They serve many purposes, provide control flow, as well as serving as Gab’s mechanism for polymorphism.\nMessage Sends The only way to do anything is by sending a message to a value.\n\"Hello world!\" .println # =\u003e Hello world! Earlier we saw message literals, which look like this:\nprintln: Now we’ve seen a message send, which is like calling a method or function:\nany_value .println Message literals can also respond to messages!\nmy_message: .println # =\u003e my_message: In fact, this is how new messages are defined in Gab!\nmy_message:.def!( myType, () =\u003e do self.name.println end) Messages themselves respond to the def!: message by adding a new implementation for the given type(s). There are several other messages for defining new implementations, which gab refers to as specializations.\n# Define multiple specializations for one message, conveniently my_message: .defcase! { nil: () =\u003e \"I was nil!\" true: () =\u003e \"I was true!\" none: \"I was none!\" # Values alone can also serve as a specialization. } # Define the same specializations for multiple types, conveniently [ myType ] .defmodule! { message_one: () =\u003e \"Sending message one\" message_two: () =\u003e \"Sending message two\" } Message Values We’ve seen message values before, they are identifiers that end in a colon:. They’re useful for singleton values - and in fact, Gab implements booleans and nil using messages. More on this in later chapters! Gab also uses message values to implement results or optionals. Since Gab has multiple return values, sends that can error often return multiple values like this:\n# This call may fail, if Gab can't open the file (ok file) = Io.open('Maybe_Exists.txt') (ok file) # =\u003e If the file exists (ok: ) # =\u003e If the file doesn't (err: \"File not found\") # This line will crash - the record doesn't respond to age: age = { name: 'bob' } .age (ok age) = { name: 'bob' }.at(age:) # Now instead we will either see: # =\u003e (ok: 44) # =\u003e (none: nil:) "},"title":"Messages"},"/docs/intro/basic_types/records/":{"data":{"":"","#":"Records are collections of key-value pairs. They are ordered and structurally typed.\nDictionaries Between the curly brackets {}, expressions are expected in key-value pairs. Any expression is allowed as a key or value.\na_record = { key: 'value' } a_record .key # =\u003e 'value' another_record = { key: 'value', 'another_key' 10 } another_record .at 'another_key' # =\u003e (ok: '10) Records, like all values in Gab, are immutable. This means that setting values in records returns a new record.\na_record = { key: 'value' } a_record = a_record .key 'another value' # =\u003e When an argument is provided, this message serves as a 'set' instead of a 'get'. a_record # =\u003e { key: 'another value' } a_record = a_record .put (key: 'something else') a_record # =\u003e { key: 'something else' } Lists Lists are constructed with the square brackets [], and any number of expressions are allowed inside. Lists are a special kind of record - one in which all they keys are ascending integers, starting from 0.\na_list = [1 2 3] a_list # =\u003e [1, 2, 3] a_list = { 0 1, 1 2, 2 3 } a_list # =\u003e [1, 2, 3] Records Both Dictionaries and Lists use the same underlying datastructure, gab\\record. In order to make these immutable data structures fast, records are implemented with a bit partitioned vector trie. Gab’s implementation is very much inspired by clojure’s immutable vectors. Records are able to share memory under the hood, to avoid copying large of data for a single key-value mutation. This is called structural sharing, and is a common optimization in immutable data structures.\nAs seen above, gab\\record implements some useful messages put: and at:.\nsome_record .at key: # =\u003e (ok:, 'value') Shapes All records have an underlying shape. They determine the available keys, and their order - think of them as an implicit class. Records with the same keys in the same order share the same shape.\nsome_record = { x: 1 y: 2 } shape_x_y = some_record ? # =\u003e ({ x: 2 y: 3 } ?) == shape_x_y # =\u003e true: Shapes are useful for defining methods. When resolving which specialization to use for a given value, Gab checks in the following order:\nIf the value has a super type, and it has an available specialization, use it. If available, use the type’s specialization. If available, use the property. If available, use the general specialization. No specialization found. For example: { x: 1 } has a super type of \u003cgab\\shape x:\u003e, and a type of gab\\record.\n# Define the message y: in the general case. y: .def! 'general case' # Define the message z: in the case of z: .def! ( Shapes.make x:, 'shape case') { x: 1 } .x # =\u003e 2 { x: 1 } .y # =\u003e 'general case' { x: 1 } .z # =\u003e 'shape case' "},"title":"Records"},"/docs/intro/basic_types/strings/":{"data":{"":"This chapter will discuss the four basic string-ish types. It is meaningful to group these four types together because they share data in memory. The string \"true\" and the message true: all the share same four bytes of memory: [ 't', 'r', 'u', 'e' ]. They differentiate their type by tagging the values slightly differently - but this is an implementation detail. The important note to take from this is that converting these types into each other (eg: 'true'.messages\\into) is a constant-time operation. There is no copying, nor memory allocation.","binaries#Binaries":"As mentioned above, the gab\\binary allows for operating on bytes directly - there is no encoding enforced. This means indexing/slicing operations are constant time. There is no syntax for constructing binary literals, but other types can be converted into binaries.\n\"This is a string\" .slice(3 8) # Requires linearly scanning from the front of the string \"This will be a binary\" .binaries\\into .slice (3 8) # slices from the 3rd to 8th byte in constant time Binaries.make('This is also makes a binary') ","strings#Strings":"Strings are sequences of UTF8-encoded bytes. Single-quoted strings support some escape sequences, including unicode.\n\"Hello!\" \"\\tHello\\n\" \"Hello \\u[2502]\" The gab\\string type responds to messages respecting its UTF-8 Encoding. This means that some operations actually take linear time, when you may expect them to be constant time. For example, slicing a UTF-8 string at a given index requires processing the string linearly - as UTF8 is a multi-byte character encoding and codepoints may be anywhere from one to four bytes long. On the other hand, the gab\\binary type is trivially convertible from gab\\string, and respects bytes directly, without enforcing or respecting any encoding. Becaues of this, converting from a gab\\binary to a gab\\string can fail if the binary is not valid UTF-8.\nsmiley = '😀' smiley.len # =\u003e 1 smiley_bin = smiley.binaries\\into # =\u003e smiley_bin.len # =\u003e 4 There is no syntax for string interpolation, but it is easy to construct strings out of other values using make:.\nfull_name = Strings.make(\"Ada\" \" \" last_name) # The fmt package also supplies the sprintf: message 'Format a value: $'.sprintf({ name: 'bob' }) # =\u003e 'Format a value: { name: bob }' "},"title":"Strings"}}