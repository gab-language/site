{"/docs/":{"data":{"":"","#":"üëã Hello! Welcome to Gab‚Äôs documentation. Here, we‚Äôll take you on a tour of the language and its features. If we‚Äôve done our job, reading through the introduction should take less than an hour.\nüê≤ Here be dragons While the language is relatively stable, Gab‚Äôs runtime and libraries are still under construction. Expect bugs and the occasional api change as things settle down. I wouldn‚Äôt consider Gab production-ready just yet. Additionally, documentation and developer tooling is lacking. The language may be hard to use until these become more mature."},"title":"Docs"},"/docs/basic_types/":{"data":{"":"","#":"In this chapter, we will learn more about Gab‚Äôs basic types. At the core of any language is its values - Gab is no different. In fact - values are almost all there is in Gab‚Äôs syntax. This introduction will build the foundation of how to think and program in Gab.\nNumbers Numbers are represented by IEEE 64-bit floating point values. There is no distinct integer type.\n1 -42 0.2 ? # =\u003e gab\\number Note\nNumbers less than one require a leading zero, as shown below.\nThis is because the plain . would conflict with another element of Gab‚Äôs syntax (a message send).\nStrings Strings are a sequence of bytes. They are UTF8-encoded. For working with raw un-encoded bytes, Gab provides gab\\binary.\n\"gab\" \"what type am I?\" ? # =\u003e gab\\string 'Single quoted strings support escaping!\\n' As seen above, the operator for inspecting the type of a value is the question mark.\nBlocks Blocks are Gab‚Äôs closures or functions. They use the familiar =\u003e syntax:\nsquare = (x) =\u003e x * x # =\u003e square.(2) # =\u003e 4 Blocks always have an implicit self local. On their own, it isn‚Äôt very useful. It will become useful later for defining message specializations.\nget_me = () =\u003e self # =\u003e get_me.() # =\u003e Messages Messages are another obscure concept, also to be explored later. In this context, think of them as atoms or keywords - values which represent themselves. Gab takes this a step further: the type of a message is also itself.\nmessage: # =\u003e message: message: ? # =\u003e message: Messages are useful as keys in records, to indicate success or failure in returning from blocks, as enumerations, and in many other ways. Messages can also be called like blocks - however, they will look up a specialization based on the receiver‚Äôs type.\n+:.(2, 2) # =\u003e 4 +:.('Hello ', 'world!') # =\u003e 'Hello world!' Instead of writing out a message literal like +: and calling it, we can use a different infix notation. For operators like +:, that should look familiar!\n2 + 2 # =\u003e 4 # We've already seen another syntax for sending messages # (ones that aren't operators) # Replace the colon `:` at the end with a dot `.` at the front, # and you've got a message send! 'Hello world!'.println Records Records are Gab‚Äôs only data structure. They serve as both dictionaries and lists.\n{ msg: 'hi' } [1, 2, 3] { name: \"Joe\" }? # =\u003e Shapes Shapes are one of the more obscure concepts in Gab. We‚Äôll explore them further later. For now, know that all records with the same set of keys (in the same order) share the same shape.\na = { name: \"Joe\" } a ? # =\u003e b = { name: \"Rich\" } b ? # =\u003e (a ?) == (b ?) # =\u003e true: Note\nA space is required between a and ?. Identifiers like a are allowed to end with either a question mark ? or an exclamation point !. This serves various conventions in Gab.\nFibers gab\\fiber is a green thread - similar to processes on the BEAM, and goroutines in golang.\nFibers.make () =\u003e do 'I could run on another os thread!' end Fibers are created as above, and automaticaly queued up for execution. The block passed to make: will run, potentially on another operating-system thread. As all Gab values are immutable, the block passed here may capture any variables it likes. However, communicating to this fiber once its created is only possible through a gab\\channel.\nChannels Channels are a synchronized portal for handing off values between two gab\\fibers.\nch = Channels.make # \u003c!: is a blocking operation to put a value onto a channel Fibers.make () =\u003e ch \u003c! 'Hello world!' # \u003e!: is the opposite - a blocking operation for taking values out. ch.\u003e!.println A fiber waiting on a channel operation may not continue executing until either the operation completes or the channel closes. To prevent fibers from hogging the CPU while they wait, they may yield the CPU to other fibers and will retry their operation at a later time.\nNote\nEven the put message \u003c!: must block until a receiver arrives to become responsible for the passing value. This is required by Gab‚Äôs runtime, as the gab\\channel value is immutable and cannot hold references to other values.","conclusion#Conclusion":"And thats it! Gab is meant to be small and composable - the core concepts are few, but they compose in powerful ways. The chapters that follow will explore these types further!"},"title":"Basic Types"},"/docs/basic_types/arithmetic/":{"data":{"":"Lots of dynamic scripting languages make the distinction between integers and floats. Python can even upgrade numbers to the heap when they would otherwise overflow their size. Gab keeps it simple - numbers are just 64-bit floats. It is possible that in the future a distinct integer type will be added.\n1 / 3 # =\u003e 0.33333 2 * 2 # =\u003e 4 "},"title":"Arithmetic"},"/docs/basic_types/blocks/":{"data":{"":"","#":"Blocks are simply functions, as seen before. But there are some additional, useful tidbits to cover:\nMultiple return values Blocks can return multiple values, similar to golang or lua. Here, open: returns two values. One signals the status of the operation, and another providing value or an error.\nIO.open('my_data.csv') # =\u003e ok: # =\u003e err: File does not exist The group of values passed to and return from a block is called a tuple. They can be unpacked like this:\n# Unpack the tuple here with parentheses (). # This is called 'destructuring' (status, stream) = IO.open('my_data.csv') status.ok?.then () =\u003e do # Do something with stream here. end # Alternatively, we can unwrap our stream: # This will crash if the first element in the tuple isn't ok: stream = IO .open('my_data.csv') .unwrap! Tuples are used heavily, and preferred to records wherever possible. While records allocate memory, tuples use the stack and require zero allocation.\nTuples Now that we‚Äôve been introduced to tuples, there are a few rules about them to learn.\n# Messages are sent to the FIRST element of the tuple. # Heres some funky syntax you *could* write: (1 2) + # =\u003e 3 (1 2) + 3 # Syntax error When the left-hand side of a send is a tuple and the right-hand side is empty, Gab emits a send to the whole left-hand tuple. When the right-hand side is not empty, Gab will emit an error.\nThis behavior means that you can forward the whole tuple returned by a block into another send, without any intermediate allocation. In fact, this is how unwrap!: is implemented!\nunwrap!: .defcase! { # If the receiver (first element of tuple) was ok: # return the result ok: (result) =\u003e result # If the receiver was err: # panic! err: (err) =\u003e 'Unwrap Failed: $'.sprintf(err).panic! } # open: returns a tuple (ok: ) # This tuple is forwarded to .unwrap! stream = IO .open('my_data.csv') .unwrap! "},"title":"Blocks"},"/docs/basic_types/booleans/":{"data":{"":"Booleans are implemented with messages - they are not built-in keywords like in other languages!\ntrue: false: There is no if in gab. Typically, a defcase is used instead:\nmy_message: .defcase! { true: (args) =\u003e do # Do something with args in the truthy case end false: (args) =\u003e do # Do something with args in the falsey case end } some_condition .my_message args For simple use cases, there are messages and:, or:, then: and else: defined in the core library.\n# Lifted from gab's core library. truthy_values .defmodule! { and: (alt[]) =\u003e alt** or: _ =\u003e self then: f =\u003e f. self else: _ =\u003e self } falsey_values .defmodule! { and: _ =\u003e self or: (alt[]) =\u003e alt** then: _ =\u003e self else: f =\u003e f. self } The and: and or: messages do what you expect for the most part, except they don‚Äôt short circuit. This means the value on the right is always evaluated.\ntrue: .and 2 # 2 false: .and 2 # .false false: .or 2 # 2 true: .or 2 # .true The then: and else: messages do short circuit, by accepting blocks instead of values.\ntrue: .then () =\u003e do # Do something in the truthy case end false: .else () =\u003e do # Do something in the falsey case end This is is the part of Gab that some may find to be most inconvenient. However, I find that it encourages writing smaller functions and more modular code, as nesting lots of scopes and conditionals is impossible."},"title":"Booleans"},"/docs/basic_types/messages/":{"data":{"":"","#":"Message are the bread and butter of Gab. They serve many purposes, provide control flow, as well as serving as Gab‚Äôs mechanism for polymorphism.\nMessage Sends The only way to do anything is by sending a message to a value.\n\"Hello world!\" .println # =\u003e Hello world! Earlier we saw message literals, which look like this:\nprintln: Now we‚Äôve seen a message send, which is like calling a method or function:\nany_value .println Message literals can also respond to messages!\nmy_message: .println # =\u003e my_message: In fact, this is how new messages are defined in Gab!\nmy_message:.def!( myType, () =\u003e do self.name.println end) Messages themselves respond to the def!: message by adding a new implementation for the given type(s). There are several other messages for defining new implementations, which gab refers to as specializations.\n# Define multiple specializations for one message, conveniently my_message: .defcase! { nil: () =\u003e \"I was nil!\" true: () =\u003e \"I was true!\" none: \"I was none!\" # Values alone can also serve as a specialization. } # Define the same specializations for multiple types, conveniently [ myType ] .defmodule! { message_one: () =\u003e \"Sending message one\" message_two: () =\u003e \"Sending message two\" } Message Values We‚Äôve seen message values before, they are identifiers that end in a colon:. They‚Äôre useful for singleton values - and in fact, Gab implements booleans and nil using messages. More on this in later chapters! Gab also uses message values to implement results or optionals. Since Gab has multiple return values, sends that can error often return multiple values like this:\n# This call may fail, if Gab can't open the file (ok file) = Io.open('Maybe_Exists.txt') (ok file) # =\u003e If the file exists (ok: ) # =\u003e If the file doesn't (err: \"File not found\") # This line will crash - the record doesn't respond to age: age = { name: 'bob' } .age (ok age) = { name: 'bob' }.at(age:) # Now instead we will either see: # =\u003e (ok: 44) # =\u003e (none: nil:) "},"title":"Messages"},"/docs/basic_types/records/":{"data":{"":"","#":"Records are collections of key-value pairs. They are ordered and structurally typed.\nDictionaries Between the curly brackets {}, expressions are expected in key-value pairs. Any expression is allowed as a key or value.\na_record = { key: 'value' } a_record .key # =\u003e 'value' another_record = { key: 'value', 'another_key' 10 } another_record .at 'another_key' # =\u003e (ok: '10) Records, like all values in Gab, are immutable. This means that setting values in records returns a new record.\na_record = { key: 'value' } a_record = a_record .key 'another value' # =\u003e When an argument is provided, this message serves as a 'set' instead of a 'get'. a_record # =\u003e { key: 'another value' } a_record = a_record .put (key: 'something else') a_record # =\u003e { key: 'something else' } Lists Lists are constructed with the square brackets [], and any number of expressions are allowed inside. Lists are a special kind of record - one in which all they keys are ascending integers, starting from 0.\na_list = [1 2 3] a_list # =\u003e [1, 2, 3] a_list = { 0 1, 1 2, 2 3 } a_list # =\u003e [1, 2, 3] Records Both Dictionaries and Lists use the same underlying datastructure, gab\\record. In order to make these immutable data structures fast, records are implemented with a bit partitioned vector trie. Gab‚Äôs implementation is very much inspired by clojure‚Äôs immutable vectors. Records are able to share memory under the hood, to avoid copying large of data for a single key-value mutation. This is called structural sharing, and is a common optimization in immutable data structures.\nAs seen above, gab\\record implements some useful messages put: and at:.\nsome_record .at key: # =\u003e (ok:, 'value') Shapes All records have an underlying shape. They determine the available keys, and their order - think of them as an implicit class. Records with the same keys in the same order share the same shape.\nsome_record = { x: 1 y: 2 } shape_x_y = some_record ? # =\u003e ({ x: 2 y: 3 } ?) == shape_x_y # =\u003e true: Shapes are useful for defining methods. When resolving which specialization to use for a given value, Gab checks in the following order:\nIf the value has a super type, and it has an available specialization, use it. If available, use the type‚Äôs specialization. If available, use the property. If available, use the general specialization. No specialization found. For example: { x: 1 } has a super type of \u003cgab\\shape x:\u003e, and a type of gab\\record.\n# Define the message y: in the general case. y: .def! 'general case' # Define the message z: in the case of z: .def! ( Shapes.make x:, 'shape case') { x: 1 } .x # =\u003e 2 { x: 1 } .y # =\u003e 'general case' { x: 1 } .z # =\u003e 'shape case' "},"title":"Records"},"/docs/basic_types/strings/":{"data":{"":"This chapter will discuss the four basic string-ish types. It is meaningful to group these four types together because they share data in memory. The string \"true\" and the message true: all the share same four bytes of memory: [ 't', 'r', 'u', 'e' ]. They differentiate their type by tagging the values slightly differently - but this is an implementation detail. The important note to take from this is that converting these types into each other (eg: 'true'.messages\\into) is a constant-time operation. There is no copying, nor memory allocation.","binaries#Binaries":"As mentioned above, the gab\\binary allows for operating on bytes directly - there is no encoding enforced. This means indexing/slicing operations are constant time. There is no syntax for constructing binary literals, but other types can be converted into binaries.\n\"This is a string\" .slice(3 8) # Requires linearly scanning from the front of the string \"This will be a binary\" .binaries\\into .slice (3 8) # slices from the 3rd to 8th byte in constant time Binaries.make('This is also makes a binary') ","strings#Strings":"Strings are sequences of UTF8-encoded bytes. Single-quoted strings support some escape sequences, including unicode.\n\"Hello!\" \"\\tHello\\n\" \"Hello \\u[2502]\" The gab\\string type responds to messages respecting its UTF-8 Encoding. This means that some operations actually take linear time, when you may expect them to be constant time. For example, slicing a UTF-8 string at a given index requires processing the string linearly - as UTF8 is a multi-byte character encoding and codepoints may be anywhere from one to four bytes long. On the other hand, the gab\\binary type is trivially convertible from gab\\string, and respects bytes directly, without enforcing or respecting any encoding. Becaues of this, converting from a gab\\binary to a gab\\string can fail if the binary is not valid UTF-8.\nsmiley = 'üòÄ' smiley.len # =\u003e 1 smiley_bin = smiley.binaries\\into # =\u003e smiley_bin.len # =\u003e 4 There is no syntax for string interpolation, but it is easy to construct strings out of other values using make:.\nfull_name = Strings.make(\"Ada\" \" \" last_name) # The fmt package also supplies the sprintf: message 'Format a value: $'.sprintf({ name: 'bob' }) # =\u003e 'Format a value: { name: bob }' "},"title":"Strings"},"/docs/intro/":{"data":{"":"Welcome!\nThis guide will teach you about Gab‚Äôs fundamentals.\nWe will discuss the basic types and ideas of the language.\nFirst, lets install the language itself.","compiling-from-source#Compiling From Source":"cgab is a C project built with Zig‚Äôs c-compiler toolchain. zig cc is chosen specifically for its cross-compiling superpowers. This enables linux developers to cross-compile for Windows and run via wine, among other amazing things. As a result, a limitation placed on cgab is that there shall be no runtime dependencies other than libc. This constraint is what makes the cross compilation possible. This goes for any c modules as well - there may be NO runtime dependencies. Any 3rd party code necessary for c modules shall be kept in git-submodules, and if it must be linked, then linked statically.\nUnix Systems To manage the various useful scripts in the repo, cgab takes advantage of clide. After installing clide, building cgab from source is as simple as running:\nclide build Clide will prompt you to select a build type and installation target. For details on how to use clide, check its readme.\nManual Build Alternatively, zig cc can be invoked manually. Check .clide/../build.sh for an example of how to invoke zig cc, and build the appropriate artifacts.\nNote\nThe additional flags -DGAB_PLATFORM_UNIX and -D_POSIX_C_SOURCE=200809L are required for unix builds. Clide relies on bash scripts written in the .clide/ directory, and therefore will not work on windows. On Windows, zig cc should be invoked manually. The following is an example, but will not fully build cgab.\nzig cc -O3 -std=c23 -fPIC -Wall --target=native -o gab -Iinclude -Ivendor -DNDEBUG -DGAB_PLATFORM_WIN src/**/*.c ","installing-the-language#Installing the language":"1. Downloading binaries from releases cgab provides pre-built cross-platform binaries upon releases. They are available in both debug and release flavors. Select a pre-built binary that matches your system. If you don‚Äôt see one, feel free to create a Github Issue or build cgab yourself.\nNote\nThe executable you just downloaded (gab) won‚Äôt be in your path. You‚Äôll need to invoke it directly. Later, Gab will recommend how to update your PATH as part of installation. Ultimately, this is up to you!\n2. Install via binary All that is needed to complete the installation is this downloaded binary! From this point forward lets refer to your downloaded binary as simply gab, just to make things easier. Now, you should be able to run Gab.\n# Try this: gab # Or this: gab help You should see a generic help message, summarazing the commands available to you. However, at this point trying to run any real code will fail - Gab‚Äôs core modules still need to be installed. Lets go ahead and complete your installation by downloading the core modules that Gab requires.\n# Gab makes this easy: gab get This command downloads the gab binary and modules to Gab‚Äôs installation prefix on your machine. You should see some logs detailing this process. Lastly, complete your installation as instructed by the message in your terminal.\nNote\ngab calls out to the operating system for curl and tar in order to perform this installation. They should be widely available by default on most machines, including any Windows machine with Windows 10 or later. However, you may see an error message indicating that one of the two is unavailable - in that case installation will fail.","windows#Windows":"Unforunately, windows is not supported at the moment. There is currently a bug in zig cc causing miscompilations on Windows which break the c abi. The features of c which cause this bug to appear are used heavily in cgab. Until this bug is fixed in zig, Gab will not support windows."},"title":"Introduction"},"/docs/recursion/":{"data":{"":"","#":"Gab does not provide form of loop construct. Instead, we use recursion and to perform the same work and rely on the cgab runtime to make it fast.\nInvestigation: reduce To investigate this further, lets look at Gab‚Äôs implementation of a standard reduce function. In JS, it may look like this:\nfunction reduce(array, f, initial) { // Setup our mutating accumulator variable let acc = initial // Iterator our array for each index for (let i = 0; i \u003c array.length; i++) { // Apply f to accumulator with current value acc = f(acc, array[initial]) } return acc } sum = reduce([1 2 3 4], (acc, curr) =\u003e acc + cur, 0) console.log(sum) // =\u003e 10 To recreate this in gab:\n# Our initial setup. # Recursion often involves a light # wrapper-function which initializes some state. reduce: .def! ( Records.t, (f, initial) =\u003e do # Begin iterating at 0th index i = 0 # Dispatch to doreduce: depending on whether or not # we had 'i' self .has? i .doreduce(self, i, f, initial) end) doreduce: .defcase! { # If we had 'i', we: # - get the current value # - apply current value to accumulator via 'f' # - increment i to next index # - Dispatch to doreduce: depending on whether or not # we had 'next' true: (record, i, f, acc) =\u003e do curr = record.at! i acc = f.(acc, curr) next = i + 1 record .has? next .doreduce(record, next, f, acc) end # If we didn't have 'i': # - our record is out of items and we can return 'acc' false: (record, i, f, acc) =\u003e acc } # Notice how we can pass the message '+:' directly, instead of # an anonymous function which wraps it. [1 2 3 4].reduce(+:, 0).println # =\u003e 10 # The anonymous function still works of course. [1 2 3 4].reduce((acc, cur) =\u003e acc + cur, 0).println # =\u003e 10 The calls to doreduce: in reduce: and doreduce: itself are tail calls.\nIn computer science, a tail call is a special type of function call that occurs as the last operation in a function before it returns a result. Specifically, when a function calls another function as its final action (and does not need to perform any further work after that call), the call is considered a tail call.\n‚Äì ChatGPT\nIn this context, cgab is able to optimize the calls to a special MATCH_TAIL_SEND op code. This op-code specializes the send as a pseudo-jumptable, allowing deep recursion and fast dispatch.\nA note on traditional recursion In functional languages which rely on recursion (such as Elixir, for example) it is common to implement recursive algorithms such as this by operating on the head of the list and recursing over the tail. Something like this:\n# Directly from Elixir's introductory documentation defmodule Math do def sum_list([head | tail], accumulator) do sum_list(tail, head + accumulator) end def sum_list([], accumulator) do accumulator end end IO.puts Math.sum_list([1, 2, 3], 0) #=\u003e 6 In the above example the [head | tail] destructuring is implemented in one of two ways:\nThe array data structure is implemented with a linked-list. Popping the head element off and continuing along the tail is a fast operation: But linked lists are slow because they don‚Äôt store their elements contiguously in memory. The array data structure is implemented with some sort of immutable array. This will store data contiguously which is great for your cpu cache, but will require copying a non-trivial amount of data on every [head | tail] operation, as well as allocating a new array for tail. Gab‚Äôs approach is to recurse over incrementing indices instead of a shrinking tail. It is more verbose, but it is also more concious of whats happening under the hood. Making N allocations in order to sum a list of size N is unnecessary.\nNote\nThis problem is not specific to Elixir at all, in fact it is a common pattern in a lot of functional languages. And it is equally possible to implement the reduce function in Gab‚Äôs style. Gab just doesn‚Äôt provide a more syntactically-pleasing alternative."},"title":"Recursion"}}