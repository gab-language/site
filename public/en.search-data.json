{"/blog/":{"data":{"":"","#":"ðŸ‘‹ Hello! Welcome to my blog about cgabâ€™s implementation. In here youâ€™ll find the gritty details of how the compiler and runtime truly work. It will be pretty technical, but hopefully with a little bit of C experience it will be understandable."},"title":"Blog"},"/blog/values/":{"data":{"":"","nan-tagging#NaN Tagging":"There is a technique among vm-implementers known as NaN tagging, which involves repurposing some of the normally useless states that a double-precision floating-point number can be in. There is an in-depth explanation in the source code, and the comment is copied at the end of this blog post.\nTo summarize, we use a special incantation bit-pattern (known as a quiet NaN) to signal that weâ€™re in one of these useless floating-point states. If we confirm a double matches our incantation, we can safely use the lower 50 bits to interpret however we choose. If it doesnâ€™t, then we should interpret it as an ordinary double.\nIn the special nan-tagging case, cgab sets aside the highest two bits to store an extra tag, leaving 48 bits below for data.\nThere is actually another state - when the sign bit is set and the incantation is found, we should interpret the lower 50 bits as a pointer to the heap. On the other side of the pointer there will be a tag and data describing the object.\nThe tag uses the same gab_kind enum that the rest of cgab uses - it describes all the types a value can possibly have.\nenum gab_kind { kGAB_STRING = 0, // MUST_STAY_ZERO kGAB_BINARY = 1, kGAB_MESSAGE = 2, kGAB_PRIMITIVE = 3, kGAB_NUMBER, // ... Lots of others omitted for brevity }; The reason that the first four values are specified is because of our NaN tagging scheme. Those four kinds need to be small enough to fit in our two-bit tag. These four tags determine the types of all the values which we can cram into our remaining 48 bits.\nShort String Optimization Using the remaining 48 bits, cgab can store up to 5 bytes of string data, including a length byte. This short string optimization is also described in the below comment. Strings, Binaries, and Messages all benefit from the short string optimization, and internally they all point to the same data. This is because the tag in the NaN-boxed value itself is what determines whether the value is a String, Binary, or Message. Because of this, converting between the 3 string-like types is quite literally trivial. Here is the code for converting a string into a binary, lifted from cgab.\ngab_value gab_strtomsg(gab_value str) { assert(gab_valkind(str) == kGAB_STRING); return str | (uint64_t)kGAB_MESSAGE \u003c\u003c __GAB_TAGOFFSET; } It simply takes the input value (which should have kGAB_STRING for its NaN tag, aka 0) and bitwise-ors in the kGAB_MESSAGE tag instead. Just two instructions!\nThis detail is why the kGAB_STRING enum must have the value 0!\nAs promised, Here is the big doc comment lifted directly from cgabâ€™s source code. It describes more in depth how the floating-point trickery and short-string optimization work.\n/** * %-------------------------------% * | Value Representation | * %-------------------------------% * * Gab values are nan-boxed. * * An IEEE 754 double-precision float is a 64-bit value with bits laid out like: * * 1 Sign bit * | 11 Exponent bits * | | 52 Mantissa * | | | * [S][Exponent---][Mantissa------------------------------------------] * * The details of how these are used to represent numbers aren't really * relevant here as long we don't interfere with them. The important bit is NaN. * * An IEEE double can represent a few magical values like NaN (\"not a number\"), * Infinity, and -Infinity. A NaN is any value where all exponent bits are set: * * NaN bits * | * [-][11111111111][----------------------------------------------------] * * The bits set above are the only relevant ones. The rest of the bits are * unused. * * NaN values come in two flavors: \"signalling\" and \"quiet\". The former are * intended to halt execution, while the latter just flow through arithmetic * operations silently. We want the latter. * * Quiet NaNs are indicated by setting the highest mantissa bit: * We also need to set the *next* highest because of some intel shenanigans. * * Highest mantissa bit * | * [-][....NaN....][11--------------------------------------------------] * * This leaves the rest of the following bits to play with. * * Pointers to objects with data on the heap set the highest bit. * * We are left with 50 bits of mantissa to store an address. * Even 64-bit machines only actually use 48 bits for addresses. * * Pointer bit set Pointer data * | | * [1][....NaN....11][--------------------------------------------------] * * Immediate values *don't* have the pointer bit set. * They also store a tag in the 2 bits just below the NaN. * This tag differentiates how to interpret the remaining 48 bits. * * kGAB_BINARY, kGAB_STRING, kGAB_MESSAGE, kGAB_PRIMITIVE * | * [0][....NaN....11][--][------------------------------------------------] * * 'Primitives' are immediates which wrap further data in the lower 48 bits. * In most cases, this value is a literal bytecode instruction. This allows * the vm to implement certain message specializations as bytecode instructions. * * There are some special cases which are not bytecode ops: * - gab_cvalid * - gab_cinvalid * - gab_ctimeout * - gab_cundefined * * These are constant values used throughout cgab. * * kGAB_PRIMITIVE Extra data * | | * [0][....NaN....11][--][------------------------------------------------] * * Gab also employs a short string optimization. Lots of strings in a gab * program are incredibly small, and incredibly common. values like * * none: * ok: * and even a send, like (1 + 1), stores a small string (for the message +:) * * We need to store the string's length, a null-terminator (for * c-compatibility), and the string's data. * * Instead of storing the length of the string, we store the amount of bytes * *not* used. Since there are a total of 5 bytes available for storing string * data, the remaining length is computed as 5 - strlen(str). * * We do this for a special case - when the string has length 5, the remaining * length is 0. In this case, the byte which stores the remaining length *also* * serves as the null-terminator for the string. * * This layout sneakily gives us an extra byte of storage in our small strings. * * kGAB_STRING Remaining Length \u003c- Data * | | | * [0][....NaN....11][--][--------][----------------------------------------] * [ 0 ][ e p a h s ] * [ 3 ][---------------- 0 k o ] * */ ","why-it-matters#Why it matters":"Why it matters In a language like C, code is compiled to run natively - values are just blocks of memory, and at runtime there is no type information. A register could hold an integer, or a pointer, or a boolean, but to the program theyâ€™re all just bits.\nThis differs from how a language like Java, Python, or Gab work. These dynamic languages also carry type information about values through runtime, and use it for garbage collection, reflection, and detecting type errors.\nDonâ€™t get mad at me for calling Java dynamic. You know it is.\nAt the runtime-level, dynamic languages need a type which can represent any value in a program. A simple (dare I say naive) way of implementing this is with a tagged union.\nstruct value { /* A 'tag' to keep track of which kind of data is in 'val' */ enum value_type t; union { /* Numeric value */ double floating; /* A boolean */ bool boolean; /* A pointer to a larger object on the heap */ void* pointer; } val; }; This works well! We can now pass around this small struct in our interpreter. Just to help you visualize, here is what a simple add instruction might look like.\nstruct value add_implementation(struct interpreter* i, struct value lhs, struct value rhs) { /* We have a type error, throw an error in our interpreter */ if (lhs.type != TYPE_NUMBER || rhs.type != TYPE_NUMBER) return throw_error(i); /* Create a new value with the result of the addition */ return (struct value) { .t = TYPE_NUMBER, .val.floating = lhs.val.floating + rhs.val.floating, }; } Alright! Weâ€™ve seen how these values can be used in our c-interpreter, and it all works nicely. What are the problems with this approach? To understand that, we need to dive a little bit deeper into how our c-interpreter actually works.\nNative programs have two types of memory - a stack and a heap. The same is true in the managed runtimes of Java, Python, and Gab. The interpreters (or virtual machines - VMs, as Iâ€™ll probably say from now on) have an internal stack, which keep track of local variables, scopes, and function calls.\nHere we have a random Python function which for the purpose of this demonstration, just makes some random calculations with arguments and variables.\ndef example(a, b): c = a + b d = a - b e = c * d return e Letâ€™s take a look at how the stack might look under the hood as this function is being called.\nDisclaimer: I am not a cpython expert. I am guessing based on what I know about it and stack vms in general.\n# Here is what the stack might look like at the callsite below. example(1, 2) # %---------% # | 2 | The second argument # %---------% # | 1 | The first argument # %---------% # | example | The function being called # %---------% # | ....... | Any local variables before, or functions being called above # %---------% # Once we're in example, it might look like this: def example(a, b): c = a + b d = a - b # \u003c-- Paused here e = c * d return e # %---------% # | -1 | Local variable d # %---------% # | 3 | Local variable c # %---------% # | 2 | The second argument (local variable b) # %---------% # | 1 | The first argument (local variable a) # %---------% # | ....... | The rest of the stack below, i.e. all the function calls that led to this one # %---------% The point Iâ€™m trying to get across is that the stack is basically a big, contiguous, array. As functions are called and scopes are entered/left, values are pushed and popped off of this array. Lets tie in our tagged-union implementation, and look at the actual memory layout of our stack at the last pause point.\nconst sz = sizeof(struct value); // 9 bytes const alignment = alignof(struct value); // 16 bytes /* Something like this: %---------% | -1 | 8 byte integer value field | ------- | | TAG_NUM | 1 byte tag | ------- | | PADDING | 7 bytes padding %---------% | 3 | Local variable c | ------- | | TAG_NUM | 1 byte tag | ------- | | PADDING | 7 bytes padding %---------% | 2 | The second argument (local variable b) | ------- | | TAG_NUM | 1 byte tag | ------- | | PADDING | 7 bytes padding %---------% | 1 | The first argument (local variable a) | ------- | | TAG_NUM | 1 byte tag | ------- | | PADDING | 7 bytes padding %---------% | ....... | The rest of the stack below, i.e. all the function calls that led to this one %---------% */ Look at this! Our vmâ€™s internal representation of our programâ€™s stack is almost 50% padding. In fact, any contiguous array of these structs wastes nearly 50% of its memory.\nThis is extremely relevant, as a runtime will keep these values in a contiguous array in many places:\nThe vmâ€™s internal stack. The internal stack of lightweight fibers/green threads. Garbage collection often involves keeping track of lists of values. Implementing data structures like lists/dictionaries/records/tuples often use contiguous arrays of values. In each of these areas, weâ€™re experiencing:\nLess relevant data can fit into the cpu caches. We allocate more memory from the kernel dynamically than we actually use. In order to fix this problem, is there a way to fit a value and a tag into 8 bytes?"},"title":"Value Representation"},"/docs/":{"data":{"":"","#":"ðŸ‘‹ Hello! Welcome to Gabâ€™s documentation. Here, weâ€™ll take you on a tour of the language and its features. If weâ€™ve done our job, reading through the introduction should take less than an hour.\nFor more of a technical and in-depth exploration of cgab itself the official Gab compiler and runtime, check out my blog.\nWhile the language is relatively stable, Gabâ€™s runtime and libraries are still under construction. Expect bugs and the occasional api change as things settle down. I wouldnâ€™t consider Gab production-ready just yet. Additionally, documentation and developer tooling is lacking. The language may be hard to use until these become more mature."},"title":"Docs"},"/docs/basic_types/":{"data":{"":"","#":"In this chapter, we will learn more about Gabâ€™s basic types. At the core of any language is its values - Gab is no different. In fact - values are almost all there is in Gabâ€™s syntax. This introduction will build the foundation of how to think and program in Gab.\nNumbers Numbers are represented by IEEE 64-bit floating point values. There is no distinct integer type.\n1 -42 0.2 ? # =\u003e gab\\number Note\nNumbers less than one require a leading zero, as shown below.\nThis is because the plain . would conflict with another element of Gabâ€™s syntax (a message send).\nStrings Strings are a sequence of bytes. They are UTF8-encoded. For working with raw un-encoded bytes, Gab provides gab\\binary.\n\"gab\" \"what type am I?\" ? # =\u003e gab\\string 'Single quoted strings support escaping!\\n' As seen above, the operator for inspecting the type of a value is the question mark.\nBlocks Blocks are Gabâ€™s closures or functions. They use the familiar =\u003e syntax:\nsquare = (x) =\u003e x * x # =\u003e square.(2) # =\u003e 4 Blocks always have an implicit self local. On their own, it isnâ€™t very useful. It will become useful later for defining message specializations.\nget_me = () =\u003e self # =\u003e get_me.() # =\u003e Messages Messages are another obscure concept, also to be explored later. In this context, think of them as atoms or keywords - values which represent themselves. Gab takes this a step further: the type of a message is also itself.\nmessage: # =\u003e message: message: ? # =\u003e message: Messages are useful as keys in records, to indicate success or failure in returning from blocks, as enumerations, and in many other ways. Messages can also be called like blocks - however, they will look up a specialization based on the receiverâ€™s type.\n+:.(2, 2) # =\u003e 4 +:.('Hello ', 'world!') # =\u003e 'Hello world!' Instead of writing out a message literal like +: and calling it, we can use a different infix notation. For operators like +:, that should look familiar!\n2 + 2 # =\u003e 4 # We've already seen another syntax for sending messages # (ones that aren't operators) # Replace the colon `:` at the end with a dot `.` at the front, # and you've got a message send! 'Hello world!'.println Records Records are Gabâ€™s only data structure. They serve as both dictionaries and lists.\n{ msg: 'hi' } [1, 2, 3] { name: \"Joe\" }? # =\u003e Shapes Shapes are one of the more obscure concepts in Gab. Weâ€™ll explore them further later. For now, know that all records with the same set of keys (in the same order) share the same shape.\na = { name: \"Joe\" } a ? # =\u003e b = { name: \"Rich\" } b ? # =\u003e (a ?) == (b ?) # =\u003e true: Note\nA space is required between a and ?. Identifiers like a are allowed to end with either a question mark ? or an exclamation point !. This serves various conventions in Gab.\nFibers gab\\fiber is a green thread - similar to processes on the BEAM, and goroutines in golang.\nFibers.make () =\u003e do 'I could run on another os thread!' end Fibers are created as above, and automaticaly queued up for execution. The block passed to make: will run, potentially on another operating-system thread. As all Gab values are immutable, the block passed here may capture any variables it likes. However, communicating to this fiber once its created is only possible through a gab\\channel.\nChannels Channels are a synchronized portal for handing off values between two gab\\fibers.\nch = Channels.make # \u003c!: is a blocking operation to put a value onto a channel Fibers.make () =\u003e ch \u003c! 'Hello world!' # \u003e!: is the opposite - a blocking operation for taking values out. ch.\u003e!.println A fiber waiting on a channel operation may not continue executing until either the operation completes or the channel closes. To prevent fibers from hogging the CPU while they wait, they may yield the CPU to other fibers and will retry their operation at a later time.\nNote\nEven the put message \u003c!: must block until a receiver arrives to become responsible for the passing value. This is required by Gabâ€™s runtime, as the gab\\channel value is immutable and cannot hold references to other values.","conclusion#Conclusion":"And thats it! Gab is meant to be small and composable - the core concepts are few, but they compose in powerful ways. The chapters that follow will explore these types further!"},"title":"Basic Types"},"/docs/basic_types/arithmetic/":{"data":{"":"","#":"Lots of dynamic scripting languages make the distinction between integers and floats. Python can even upgrade numbers to the heap when they would otherwise overflow their size. Gab keeps it simple - numbers are just 64-bit floats. It is possible that in the future a distinct integer type will be added.\n1 / 3 # =\u003e 0.33333 2 * 2 # =\u003e 4 A note on bit-shifting The bit-shift operators \u003c\u003c and \u003e\u003e are particularly interesting to implement. Dynamic languages do this slightly differently. In the normal case, shifting does divisions or multiplications by 2.\n4 \u003c\u003c 1 # =\u003e 8 4 \u003e\u003e 1 # =\u003e 2 However, there are some corner cases which are actually undefined behavior in c. Dynamic languages implemented on top of c need to define this behavior. Shifting left or right by a negative amount is undefined behavior\n4 \u003c\u003c -1 4 \u003e\u003e -1 Most dynamic languages replace these with an equal shift in the opposite direction (Javascript, python, lua, ruby). Gab matches this behavior.\n4 \u003e\u003e -1 # =\u003e 8 4 \u003c\u003c -1 # =\u003e 2 Shifting left or right by a number greater than the width of the integer is undefined behavior.\n# What does this mean? 4 \u003e\u003e 65 4 \u003c\u003c 65 A lot of dynamic languages implement this by just returning 0 - which makes sense when you think about a shift conceptually. This is what Gab does. Additionally, it is important to note that for these bitwise or integer operations, Gab uses 52-bit integers. This is because 64-bit integers are not completely representable with a 64-bit float. In order to guarantee lossless conversion between the number types, Gab limits integers to 52 bits.\n1 \u003c\u003c 52 # =\u003e -4.5036e+15 1 \u003c\u003c 53 # =\u003e 0 Notably, Javascript diverges here:\n1 \u003c\u003c 31 // =\u003e -2147483648 1 \u003c\u003c 32 // =\u003e 1 // If it isn't clear whats happening here: const INT_WIDTH = 32 1 \u003c\u003c (31 % INT_WIDTH) // =\u003e -2147483648 1 \u003c\u003c (32 % INT_WIDTH) // =\u003e 1 This is the most nasty of the corner cases. Bit shfiting negative integers is confusing!\n# left-shifting a negative integer is undefined behavior -1 \u003c\u003c 1 # right-shifting a negative integer is implementation defined -1 \u003e\u003e 1 Python, Javascript, and Ruby maintain the divide/multiply by two semantics that work on positive integers. However, this isnâ€™t behavior that you would actually see in the hardware. As mentioned above, shifting negative integers is either implementation defined or undefined behavior. Luaâ€™s bit shifting works like this:\n-4 \u003e\u003e 1 -- 9223372036854775806 -4 \u003c\u003c 1 -- -8 This is because lua performs the shift operation on unsigned integers, so the -4 wraps around (due to underflow) into a really large number, which is then bitshifted to the right by one, and then converted back into a signed integer. This avoids the icky behavior of shifting signed integers in C, but does mean shifting positive and negative integers has asymmetrical semantics. It is also more performant than a symmetrical implementation, because less checks/conversions are required. Gab chooses this route, as shifting negative integers is not a common enough operation to warrant the extra checks and implementaiton effort."},"title":"Arithmetic"},"/docs/basic_types/blocks/":{"data":{"":"","#":"Blocks are simply functions, as seen before. But there are some additional, useful tidbits to cover in this chapter.\nMultiple return values Blocks can return multiple values, similar to golang or lua. Here, open: returns two values. One signals the status of the operation, and another providing value or an error.\nIO.file('my_data.csv') # =\u003e ok: # =\u003e err: File does not exist The group of values passed to and return from a block is called a tuple. They can be unpacked like this:\n# Unpack the tuple here with parentheses (). # This is called 'destructuring' (status, stream) = IO.file('my_data.csv') status.ok.then () =\u003e do # Do something with stream here. end # Alternatively, we can unwrap our stream: # This will crash if the first element in the tuple isn't ok: stream = IO .file('my_data.csv') .unwrap Tuples are used heavily, and preferred to records wherever possible. While records allocate memory, tuples use the interpreterâ€™s stack and do not require allocation.\nTuples Now that weâ€™ve been introduced to tuples, there are a few rules about them to learn.\n# Messages are sent to the FIRST element of a tuple. # Heres some funky syntax you *could* write: (1 2) + # =\u003e 3 (1 2) + 3 # =\u003e 4 When the left-hand side of a send is a tuple and the right-hand side is empty, Gab emits a send to the whole left-hand tuple. When the right-hand side is not empty, Gab will trim the left hand side to one value, and then send the message to that value with the right-hand tuple as arguments.\nThis behavior means that you can forward entire tuples returned by blocks into new message sends, without any intermediate allocation. In fact, this is how unwrap: is implemented!\nunwrap: .defcase { # If the receiver (first element of tuple) was ok: then return the result ok: result =\u003e result # If the receiver was err: then panic err: err =\u003e 'Unwrap Failed: $'.panicf err } # file: returns a tuple (ok: ) # This tuple is forwarded to .unwrap stream = IO .file('my_data.csv') .unwrap "},"title":"Blocks"},"/docs/basic_types/booleans/":{"data":{"":"Booleans are implemented with messages - they are not built-in keywords like in other languages!\ntrue: false: There is no if in gab. Typically, a defcase is used instead:\nmy_message: .defcase! { true: (args) =\u003e do # Do something with args in the truthy case end false: (args) =\u003e do # Do something with args in the falsey case end } some_condition .my_message args For simple use cases, there are messages and:, or:, then: and else: defined in the core library.\n# Lifted from gab's core library. truthy_values .defmodule! { and: (alt[]) =\u003e alt** or: _ =\u003e self then: f =\u003e f. self else: _ =\u003e self } falsey_values .defmodule! { and: _ =\u003e self or: (alt[]) =\u003e alt** then: _ =\u003e self else: f =\u003e f. self } The and: and or: messages do what you expect for the most part, except they donâ€™t short circuit. This means the value on the right is always evaluated.\ntrue: .and 2 # 2 false: .and 2 # .false false: .or 2 # 2 true: .or 2 # .true The then: and else: messages do short circuit, by accepting blocks instead of values.\ntrue: .then () =\u003e do # Do something in the truthy case end false: .else () =\u003e do # Do something in the falsey case end This is is the part of Gab that some may find to be most inconvenient. However, I find that it encourages writing smaller functions and more modular code, as nesting lots of scopes and conditionals is impossible."},"title":"Booleans"},"/docs/basic_types/messages/":{"data":{"":"","#":"Message are the bread and butter of Gab. They serve many purposes. Mainly they provide control flow, or act as enums or sentinel values. However, They also serve as Gabâ€™s mechanism for polymorphism.\nMessage Sends The only way to do anything is by sending a message to a value.\n\"Hello world!\" .println # =\u003e Hello world! Earlier we saw message literals, which look like this:\nprintln: Now weâ€™ve seen a message send, which is like calling a method or function:\nany_value .println Message literals can also respond to messages!\nmy_message: .println # =\u003e my_message: In fact, this is how new messages are defined in Gab!\nmy_message:.def( myType, () =\u003e do self.name.println end) Messages themselves respond to the def: message by adding a new implementation for the given type(s). There are several other messages for defining new implementations, which Gab refers to as specializations.\n# Define multiple specializations for one message, conveniently my_message: .defcase { nil: () =\u003e \"I was nil!\" true: () =\u003e \"I was true!\" none: \"I was none!\" # Values alone can also serve as a specialization. } # Define the same specializations for multiple types, conveniently [ myType, myOtherType ] .defmodule { message_one: () =\u003e \"Sending message one\" message_two: () =\u003e \"Sending message two\" } Message Values Weâ€™ve seen message values before. They are identifiers that end in a colon:. Theyâ€™re useful for singleton or sentinel values - and in fact, Gab implements booleans and nil using messages. More on this in later chapters! Gab also uses message values to implement results or optionals. Since Gab has multiple return values, sends that can error often return multiple values like this:\n# This call may fail, if Gab can't open the file (ok file) = IO.file('Maybe_Exists.txt') (ok file) # =\u003e If the file exists (ok: ) # =\u003e If the file doesn't (err: \"File not found\") # This line will crash - the record doesn't respond to age: age = { name: 'bob' } .age (ok age) = { name: 'bob' }.at(age:) # Now instead we will either see: # =\u003e (ok: ) # =\u003e (none: nil:) "},"title":"Messages"},"/docs/basic_types/records/":{"data":{"":"","#":"Records are collections of key-value pairs. They are ordered and structurally typed. In Gab they come in two flavors - Dictionaries and Lists.\nDictionaries Dictionaries are Gab records which allow arbitrary values as keys. They are denoted with {}.\nBetween the curly brackets, expressions are expected in key-value pairs. Any expression is allowed as either a key or value.\na_record = { key: 'value' } a_record .key # =\u003e 'value' another_record = { key: 'value', 'another_key' 10 } another_record .at 'another_key' # =\u003e (ok: '10) Lists Lists are records which allow only monotonically-increasing-integer values as keys. This is some fancy talk for saying it only allows for keys 0-n.\nLists are constructed with the square brackets [], and any number of expressions are allowed inside.\na_list = [1 2 3] a_list # =\u003e [1, 2, 3] a_list = { 0 1, 1 2, 2 3 } a_list # =\u003e [1, 2, 3] Note - you can construct a list with the same syntax as a dictionary by typing in those integer keys yourself. Gab will still consider it a list-type record.\nWhile you are allowed to set any key on a list, keep in mind that Gab will transition the list into a dictionary.\na_list = [1 2 3] # =\u003e [1, 2, 3] a_list = a_list.put(name: 'bob') #=\u003e { 0 1, 1 2, 2 3, name: bob } Records The rest of this chapter is about gab\\record itself, and therefore applies to both dictionary and list flavors.\nRecords, like all values in Gab, are immutable. This means that setting values in records returns a new record.\na_record = { key: 'value' } a_record # =\u003e { key: 'another value' } a_record = a_record .put (key: 'something else') a_record # =\u003e { key: 'something else' } Both Dictionaries and Lists use the same underlying datastructure, gab\\record. In order to make these immutable data structures fast, records are implemented with a bit partitioned vector trie. Gabâ€™s implementation is very much inspired by clojureâ€™s immutable vectors. Because of this implementation, records are able to share memory under the hood, to avoid copying large of data for a single key-value mutation. This is called structural sharing, and is a common optimization among immutable data structures.\nAs seen above, gab\\record implements some useful messages put: and at:.\nsome_record .at key: # =\u003e (ok:, 'value') Shapes All records have an underlying shape. Shapes determine what the available keys are, and their order. It might be useful to think of shapes as an implicit class. Records with the same keys in the same order share the same shape.\nsome_record = { x: 1 y: 2 } shape_x_y = some_record? # =\u003e ({ x: 2 y: 3 }?) == shape_x_y # =\u003e true: Shapes are useful for defining specializations. When resolving which specialization to use for a given value, Gab checks in the following order:\nIf the value has a super type, and said super type has an available specialization, use it. If available, use the typeâ€™s specialization. If available, use the property. If available, use the general specialization. No specialization found. For example: { x: 1 } has a super type of \u003cgab\\shape x:\u003e, and a type of gab\\record.\n# Define the message y: in the general case. y: .def 'general case' # Define the message z: in the case of z: .def ( Shapes.make x:, 'shape case') { x: 1 }.x # =\u003e 1 { x: 1 }.y # =\u003e 'general case' { x: 1 }.z # =\u003e 'shape case' "},"title":"Records"},"/docs/basic_types/strings/":{"data":{"":"This chapter will discuss the three basic string-ish types. It is meaningful to group these three types together because they share data in memory. The string \"true\" and the message true: each share the same four bytes of memory in the heap: [ 't', 'r', 'u', 'e' ]. The values differentiate their type by tagging themeselves slightly differently - but this is an implementation detail. The important note to take from this is that converting these types into each other (eg: 'true'.messages\\into) is a constant-time operation. There is no copying, nor memory allocation.","binaries#Binaries":"As mentioned above, the gab\\binary operates on bytes directly - there is no encoding enforced. This means indexing/slicing operations are constant-time. There is no syntax for constructing binary literals, but other types can be converted into binaries.\n# Requires linearly scanning from the front of the string \"This is a string\".slice(3 8) # slices from the 3rd to 8th byte in constant time \"This will be a binary\".to\\b.slice(3 8) ","strings#Strings":"Strings are sequences of UTF8-encoded bytes. Single-quoted strings support some escape sequences, while double-quoted strings do not.\n\"Hello!\" '\\tHello\\n' 'Hello \\u[2502]' The gab\\string type respects its UTF-8 Encoding. Operations that would be constant time fora gab\\binary may actually be linear time for a gab\\string. For example, slicing a UTF-8 string at a given index requires processing the string linearly. This is because UTF8 is a multi-byte character encoding and codepoints may be anywhere from one to four bytes long.\nOn the other hand, the gab\\binary type is trivially convertible from gab\\string, and respects bytes directly, without enforcing or respecting any encoding. Becaues of this, converting from a gab\\binary to a gab\\string can fail if the binary is not valid UTF-8.\nsmiley = 'ðŸ˜€' smiley.len # =\u003e 1 smiley_bin = smiley.to\\b # =\u003e smiley_bin.len # =\u003e 4 There is no syntax for string interpolation, but it is easy to construct strings out of other values using make: or sprintf:.\nfull_name = Strings.make(\"Ada\" \" \" last_name) 'Format a value: $'.sprintf({ name: 'bob' }) # =\u003e 'Format a value: { name: bob }' "},"title":"Strings"},"/docs/intro/":{"data":{"":"Welcome!\nThis guide will teach you about Gabâ€™s fundamentals.\nWe will discuss the basic types and ideas of the language.\nFirst, lets install the language itself.","compiling-from-source#Compiling From Source":"cgab is a C project built with Zigâ€™s c-compiler toolchain. zig cc is chosen specifically for its cross-compiling superpowers. This enables linux developers to cross-compile for Windows and run via wine, among other amazing things. As a result, a limitation placed on cgab is that there shall be no runtime dependencies other than libc. This constraint is what makes the cross compilation possible. This goes for any c modules as well - there may be NO runtime dependencies. Any 3rd party code necessary for c modules shall be kept in git-submodules, and if it must be linked, then linked statically.\nUnix Systems To manage the various useful scripts in the repo, cgab takes advantage of clide. After installing clide, building cgab from source is as simple as running:\nclide build Clide will prompt you to select a build type and installation target. For details on how to use clide, check its readme.\nManual Build Alternatively, zig cc can be invoked manually. Check .clide/../build.sh for an example of how to invoke zig cc, and build the appropriate artifacts.\nNote\nThe additional flags -DGAB_PLATFORM_UNIX and -D_POSIX_C_SOURCE=200809L are required for unix builds. Clide relies on bash scripts written in the .clide/ directory, and therefore will not work on windows. On Windows, zig cc should be invoked manually. The following is an example, but will not fully build cgab.\nzig cc -O3 -std=c23 -fPIC -Wall --target=native -o gab -Iinclude -Ivendor -DNDEBUG -DGAB_PLATFORM_WIN src/**/*.c ","installing-the-language#Installing the language":"1. Downloading binaries from releases cgab provides pre-built cross-platform binaries upon releases. They are available in both debug and release flavors. Select a pre-built binary that matches your system. If you donâ€™t see one, feel free to create a Github Issue or build cgab yourself.\nNote\nThe executable you just downloaded (gab) wonâ€™t be in your path. Youâ€™ll need to invoke it directly. Later, Gab will recommend how to update your PATH as part of installation. Ultimately, this is up to you!\n2. Install via binary All that is needed to complete the installation is this downloaded binary! From this point forward lets refer to your downloaded binary as simply gab, just to make things easier. Now, you should be able to run Gab.\n# Try this: gab # Or this: gab help You should see a generic help message, summarazing the commands available to you. However, at this point trying to run any real code will fail - Gabâ€™s core modules still need to be installed. Lets go ahead and complete your installation by downloading the core modules that Gab requires.\n# Gab makes this easy: gab get This command downloads the gab binary and modules to Gabâ€™s installation prefix on your machine. You should see some logs detailing this process. Lastly, complete your installation as instructed by the message in your terminal.\nNote\ngab calls out to the operating system for curl and tar in order to perform this installation. They should be widely available by default on most machines, including any Windows machine with Windows 10 or later. However, you may see an error message indicating that one of the two is unavailable - in that case installation will fail.","windows#Windows":"Unforunately, windows is not supported at the moment. There is currently a bug in zig cc causing miscompilations on Windows which break the c abi. The features of c which cause this bug to appear are used heavily in cgab. Until this bug is fixed in zig, Gab will not support windows."},"title":"Introduction"},"/docs/recursion/":{"data":{"":"","#":"Gab does not provide form of loop construct. Instead, we use recursion and to perform the same work and rely on the cgab runtime to make it fast.\nInvestigation: reduce To investigate this further, lets look at Gabâ€™s implementation of a standard reduce function. In JS, it may look like this:\nfunction reduce(array, f, initial) { // Setup our mutating accumulator variable let acc = initial // Iterator our array for each index for (let i = 0; i \u003c array.length; i++) { // Apply f to accumulator with current value acc = f(acc, array[initial]) } return acc } sum = reduce([1 2 3 4], (acc, curr) =\u003e acc + cur, 0) console.log(sum) // =\u003e 10 To recreate this in gab:\n# Our initial setup. # Recursion often involves a light # wrapper-function which initializes some state. reduce: .def ( Records.t, (f, initial) =\u003e do # Begin iterating at 0th index i = 0 # Dispatch to doreduce: depending on whether or not # we had 'i' self .has i .doreduce(self, i, f, initial) end) doreduce: .defcase { # If we had 'i', we: # - get the current value # - apply current value to accumulator via 'f' # - increment i to next index # - Dispatch to doreduce: depending on whether or not # we had 'next' true: (record, i, f, acc) =\u003e do curr = record.at i acc = f.(acc, curr) next = i + 1 record .has next .doreduce(record, next, f, acc) end # If we didn't have 'i': # - our record is out of items and we can return 'acc' false: (record, i, f, acc) =\u003e acc } # Notice how we can pass the message '+:' directly, instead of # an anonymous function which wraps it. [1 2 3 4].reduce(+:, 0).println # =\u003e 10 # The anonymous function still works of course. [1 2 3 4].reduce((acc, cur) =\u003e acc + cur, 0).println # =\u003e 10 The calls to doreduce: in reduce: and doreduce: itself are tail calls.\nIn computer science, a tail call is a special type of function call that occurs as the last operation in a function before it returns a result. Specifically, when a function calls another function as its final action (and does not need to perform any further work after that call), the call is considered a tail call.\nâ€“ ChatGPT\nIn this context, cgab is able to optimize the calls to a special MATCH_TAIL_SEND op code. This op-code specializes the send as a pseudo-jumptable, allowing deep recursion and fast dispatch.\nA note on traditional recursion In functional languages which rely on recursion (such as Elixir, for example) it is common to implement recursive algorithms such as this by operating on the head of the list and recursing over the tail. Something like this:\n# Directly from Elixir's introductory documentation defmodule Math do def sum_list([head | tail], accumulator) do sum_list(tail, head + accumulator) end def sum_list([], accumulator) do accumulator end end IO.puts Math.sum_list([1, 2, 3], 0) #=\u003e 6 In the above example the [head | tail] destructuring is implemented in one of two ways:\nThe array data structure is implemented with a linked-list. Popping the head element off and continuing along the tail is a fast operation: But linked lists are slow because they donâ€™t store their elements contiguously in memory. The array data structure is implemented with some sort of immutable array. This will store data contiguously which is great for your cpu cache, but will require copying a non-trivial amount of data on every [head | tail] operation, as well as allocating a new array for tail. Gabâ€™s approach is to recurse over incrementing indices instead of a shrinking tail. It is more verbose, but it is also more concious of whats happening under the hood. Making N allocations in order to sum a list of size N is unnecessary.\nNote\nThis problem is not specific to Elixir at all, in fact it is a common pattern in a lot of functional languages. And it is equally possible to implement the reduce function in Gabâ€™s style. Gab just doesnâ€™t provide a more syntactically-pleasing alternative."},"title":"Recursion"}}